// Generated by Workman compiler
import { listFoldl, listTake } from "../std/list.mjs";
import { char } from "../std/string.mjs";
import { stringToList, stringConcat, intToString } from "../std/nativeString.mjs";
import { charEq, add, sub, mul, div, cmpInt, eq, neq, lt, gt, lte, gte, boolAnd, boolOr, not, print } from "../std/prelude.mjs";
import { callInfectious, nativeStringFromLiteral, recordGetInfectious } from "../runtime.mjs";
const charNewline = (() => {
  const __match_scrutinee = callInfectious(char, nativeStringFromLiteral("\n"));
  if (((__match_scrutinee)?.tag === "Ok") && ((__match_scrutinee)?.type === "Result")) {
    const code = ((__match_scrutinee)._0);
    return code;
  }
  if (((__match_scrutinee)?.tag === "Err") && ((__match_scrutinee)?.type === "Result")) {
    return 10;
  }
  throw new Error("Non-exhaustive patterns at runtime");
})();
const getLineAndColumn = (source, position) => {
  return (() => {
    const sourceText = (listTake)((stringToList)(source), position);
    return (() => {
      const initial = ({ "line": 1, "column": 1 });
      return (listFoldl)((state, code_0) => {
        return (() => {
          const __match_scrutinee_1 = (code_0 === charNewline);
          if (((__match_scrutinee_1) === true)) {
            return ({ "line": (recordGetInfectious(state, "line") + 1), "column": 1 });
          }
          if (true) {
            return ({ "line": recordGetInfectious(state, "line"), "column": (recordGetInfectious(state, "column") + 1) });
          }
          throw new Error("Non-exhaustive patterns at runtime");
        })();
      }, initial, sourceText);
    })();
  })();
};
export { getLineAndColumn, charNewline };
