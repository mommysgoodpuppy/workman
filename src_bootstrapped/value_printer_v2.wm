-- value_printer.wm (v2 - with real std imports)
-- Runtime value printer for Workman using std library

from "std/list" import { listMap, listJoin };
from "std/string" import { strConcat, intToString, fromLiteral };

-- ============================================================================
-- ADT Definitions
-- ============================================================================

type RuntimeValue = 
  | Unit
  | Int<Int>
  | Bool<Bool>
  | Char<Int>
  | String<List<Int>>
  | Tuple<List<RuntimeValue>>
  | Data<List<Int>, List<RuntimeValue>>
  | Closure
  | Native<List<Int>>;

-- ============================================================================
-- Value Printer Implementation
-- ============================================================================

export let rec formatRuntimeValue = match(value) {
  Unit => { fromLiteral("()") },
  Int(n) => { intToString(n) },
  Bool(b) => {
    match(b) {
      true => { fromLiteral("true") },
      false => { fromLiteral("false") }
    }
  },
  Char(code) => {
    strConcat((fromLiteral("'"), strConcat((Link(code, Empty), fromLiteral("'")))))
  },
  String(chars) => { chars },
  Tuple(elements) => {
    match(elements) {
      Empty => { fromLiteral("()") },
      Link(_, _) => {
        let formatted = listMap((formatRuntimeValue, elements));
        let inner = listJoin((fromLiteral(", "), formatted));
        strConcat((fromLiteral("("), strConcat((inner, fromLiteral(")")))))
      }
    }
  },
  Data(constructor, fields) => {
    match(fields) {
      Empty => { constructor },
      Link(_, _) => {
        let formattedFields = listMap((formatRuntimeValue, fields));
        let inner = listJoin((fromLiteral(" "), formattedFields));
        strConcat((constructor, strConcat((fromLiteral(" "), inner))))
      }
    }
  },
  Closure => { fromLiteral("<closure>") },
  Native(name) => {
    strConcat((fromLiteral("<native "), strConcat((name, fromLiteral(">")))))
  }
};
