from "std/result/core" import { IOk, IErr };
from "std/result" import { map };
from "std/nativeString" import { stringToList, stringConcat, intToString };

-- Define a simple error type for testing
type TestError = Err1 | Err2;

-- Functions that return specific errors
let makeErr1 = () => { IErr(Err1) };
let makeErr2 = () => { IErr(Err2) };

record t1 { err1: Int, err2: Int };
record t2 { add1: Int, add2: Int };

-- Recursive function to trigger errors: Err1 for n=1,2; Err2 for n=3
let rec triggerErrors = (n: Int) => {
  if (n == 0) {
    .{ err1: 0, err2: 0 }
  } else {
    let res = if (n <= 2) {
      makeErr1()
    } else {
      makeErr2()
    };

    let prev = triggerErrors(n - 1);
    let adds = match(res) {
      IOk(_) => {
        print("ok");
        .{ add1: 0, add2: 0 }
      },
      IErr(Err1) => {
        print("err1");
        .{ add1: 1, add2: 0 }
      },
      IErr(Err2) => {
        print("err2");
        .{ add1: 0, add2: 1 }
      },
      IErr(_) => {
        print("wtf");
        .{ add1: 0, add2: 0 }
      } -- Should not happen
    };
    .{ err1: prev.err1 + adds.add1, err2: prev.err2 + adds.add2 }
  }
};

let main = () => {
  let counts = triggerErrors(3);
  print(counts.err1 * 10 + counts.err2) -- Should print 21 if matching works
};