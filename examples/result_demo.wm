-- Demonstration of nested HM inference with user-defined types.
type IoError = Timeout | Disconnected;

-- Ensure sensor feeds always have at least one reading.
let ensureRecent = match(readings) {
  Link(first, rest) => { Ok(Link(first, rest)) },
  Empty => { Err(Timeout) }
};

-- Inspect connectivity and propagate detailed errors.
let connect = match(status) {
  true => { Ok(Link(0, Empty)) },
  false => { Err(Disconnected) }
};

-- First-class binder for Result values.
let bindResult = match(result, onOk) {
  (Ok(value), onOk) => { onOk(value) },
  (Err(error), _) => { Err(error) }
};

-- Combine connectivity and readings into a single Result value.
let loadSnapshot = (status) => {
  (readings) => {
    bindResult(
      connect(status),
      (seed) => {
        bindResult(
          ensureRecent(readings),
          (latest) => {
            Ok(Link(0, latest))
          }
        )
      }
    )
  }
};

-- Recursive function to sum all readings in a Result.
let rec sumReadings = match(result) {
  Ok(Link(x, rest)) => {
    match(sumReadings(Ok(rest))) {
      Ok(sum) => { Ok(0) },
      Err(e) => { Err(e) }
    }
  },
  Ok(Empty) => { Ok(0) },
  Err(e) => { Err(e) }
};

-- Example inputs drive inference toward Result<List<Int>, IoError>.
let healthyFeed = () => {
  loadSnapshot(true)(Link(7, Link(4, Empty)))
};
let offlineFeed = () => {
  loadSnapshot(false)(Empty)
};
