from "std/nativeString" import { stringToList, stringConcat, intToString };
from "std/string" import { strEq };
from "std/list" import * as list;
from "std/string" import { charToDigit, char };
from "std/char" import { charToInt };
from "std/coretypes" import { Some, None, IOk, IErr };

type ParseResult =
  | NotMul
  | ExpectedDigit
  | ExpectedComma
  | ExpectedCloseParen;

record ParseStep = { value: Int, next: Int };

-- Build a cursor/value pair for downstream helpers.
let makeStep = (v, n) => {
  .{ value= v, next= n }
};

let charComma = char(",");
let charCloseParen = char(")");
let mulLiteral = stringToList("mul("); -- String literal â†’ List<Int>
let mulLiteralLength = list.length(mulLiteral);

let infectOption = (in) => {
  match(in) {
    Some(thing) => { IOk(thing) },
    None => { IErr("none") },
    _ => {Panic("WTF")}
  }
};

-- Read exactly one digit or raise ExpectedDigit to the caller.
let readRequiredDigit = (chars, i) => {
  match(list.at(chars, i)) {
    IOk(c) => {
      match(charToDigit(c)) {
        Some(d) => { makeStep(IOk(d), i + 1) },
        None => { makeStep(IErr("none"), i + 1) }
      }
    },
    IErr(err) => { makeStep(IErr(err), i + 1) }
  }
};

-- Extend up to three total digits, stopping cleanly if parsing fails.
let rec extendDigits = (chars, step, count) => {
  if (count == 3) {
    step
  } else {
    match(list.at(chars, step.next)) {
      IErr(_) => { step },
      IOk(code) => {
        match(code :> charToDigit :> infectOption) {
          IErr(_) => { step },
          IOk(digit) => {
            let combined = makeStep(
              step.value * 10 + digit,
              step.next + 1
            );
            extendDigits(chars, combined, count + 1)
          }
        }
      }
    }
  }
};

-- Require a specific delimiter at the cursor.
let expectCharAt = (chars, i, expected, error) => {
  match(list.at(chars, i)) {
    IOk(code) => {
      if (code == expected) {
        IOk(i + 1)
      } else {
        IErr(error)
      }
    },
    _ => { IErr(error) }
  }
};

-- Check for the mul( literal at a position, otherwise resume scanning.
let expectMulLiteral = (chars, i) => {
  if (chars :> list.slice(i, i + mulLiteralLength) :> strEq(mulLiteral)) {
    IOk(i + mulLiteralLength)
  } else {
    IErr(NotMul)
  }
};

-- Parse mul(X,Y) at an index and return the product plus next cursor.
let parseMulAt = (chars, i) => {
  let afterMul = chars :> expectMulLiteral(i);
  let leftStep = extendDigits(chars, readRequiredDigit(chars, afterMul), 1);
  let afterComma = expectCharAt(chars, leftStep.next, charComma, ExpectedComma);
  let rightStep = extendDigits(chars, readRequiredDigit(chars, afterComma), 1);
  makeStep(
    leftStep.value * rightStep.value,
    expectCharAt(chars, rightStep.next, charCloseParen, ExpectedCloseParen)
  )
};

-- Walk the memory, summing successful multiplications.
let rec scan = (chars, i, acc) => {
  match(list.at(chars, i)) {
    IErr(_) => { acc },
    IOk(_) => {
      match(parseMulAt(chars, i)) {
        IOk(step) => { scan(chars, step.next, acc + step.value) },
        IErr(err) => {
          print(err);
          print(stringConcat("skipping at ", intToString(i)));
          scan(chars, i + 1, acc)
        }
      }
    }
  }
};

let corruptedMemory = stringToList("xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))");

let main = () => {
  print(scan(corruptedMemory, 0, 0))
};
