import { parse } from "std/flags/mod.ts";
import { relative, resolve } from "std/path/mod.ts";

import { compileWorkmanGraph } from "../backends/compiler/frontends/workman.ts";
import { emitModule } from "../backends/compiler/js/emitter.ts";

const flags = parse(Deno.args, {
  string: ["module", "runtime", "extension", "out"],
  boolean: ["list", "help"],
  default: {
    runtime: "./backends/compiler/js/runtime.mjs",
    extension: ".js",
  },
});

if (flags.help || flags._.length === 0) {
  printUsage();
  Deno.exit(flags.help ? 0 : 1);
}

const entryArg = String(flags._[0]);
const { coreGraph } = await compileWorkmanGraph(entryArg);

if (flags.list) {
  for (const path of coreGraph.order) {
    const displayPath = relative(Deno.cwd(), path);
    console.log(displayPath.startsWith("..") ? path : displayPath);
  }
  Deno.exit(0);
}

const targetModulePath = flags.module
  ? resolve(Deno.cwd(), flags.module)
  : coreGraph.entry;

const moduleKey = findModuleKey(coreGraph.modules, targetModulePath);
if (!moduleKey) {
  console.error(`Unable to locate module '${flags.module ?? targetModulePath}'.`);
  console.error("Use --list to inspect available module paths.");
  Deno.exit(1);
}

const module = coreGraph.modules.get(moduleKey)!;

const code = emitModule(module, coreGraph, {
  extension: flags.extension,
  runtimeModule: flags.runtime,
});

if (flags.out) {
  const outputPath = resolve(Deno.cwd(), flags.out);
  await Deno.writeTextFile(outputPath, code);
  console.error(`Wrote emitted module to ${outputPath}`);
} else {
  console.log(code);
}

function printUsage(): void {
  console.log(`Usage: deno run -A debugScripts/emit_module.ts <entry> [options]

Emit the JavaScript module generated by the Workman JS backend.

Options:
  --module <path>      Path of a module within the graph to emit (defaults to graph entry).
  --runtime <specifier>  Module specifier used for runtime helpers (default: ./backends/compiler/js/runtime.mjs).
  --extension <ext>    File extension for relative imports (default: .js).
  --out <file>         Write the generated code to a file instead of stdout.
  --list               List the modules discovered in the compiled graph and exit.
  --help               Show this message and exit.
`);
}

function findModuleKey(
  modules: ReadonlyMap<string, unknown>,
  candidate: string,
): string | undefined {
  const normalizedCandidate = normalize(candidate);
  for (const key of modules.keys()) {
    if (key === candidate) {
      return key;
    }
    if (normalize(key) === normalizedCandidate) {
      return key;
    }
  }
  return undefined;
}

function normalize(path: string): string {
  return path.replace(/\\/g, "/");
}
