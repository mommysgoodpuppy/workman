from "std/list" import { listSlice, listFilter, listAt, listTake, listLength, listTakeUntil, listSplitBy, listMap, listUncons, listFoldr };
from "std/string" import { isDigit, charCToString, char, posIntStringToInt };
from "std/nativeString" import { stringToList, stringConcat, intToString };
from "std/result" import { stripErr };

let input = "L1, R3, R1, L5, L2, L5, R4, L2, R2, R2, L2, R1, L5, R3, L4, L1, L2, R3, R5, L2, R5, L1, R2, L5, R4, R2, R2, L1, L1, R1, L3, L1, R1, L3, R5, R3, R3, L4, R4, L2, L4, R1, R1, L193, R2, L1, R54, R1, L1, R71, L4, R3, R191, R3, R2, L4, R3, R2, L2, L4, L5, R4, R1, L2, L2, L3, L2, L1, R4, R1, R5, R3, L5, R3, R4, L2, R3, L1, L3, L3, L5, L1, L3, L3, L1, R3, L3, L2, R1, L3, L1, R5, R4, R3, R2, R3, L1, L2, R4, L3, R1, L1, L1, R5, R2, R4, R5, L1, L1, R1, L2, L4, R3, L1, L3, R5, R4, R3, R3, L2, R2, L1, R4, R2, L3, L4, L2, R2, R2, L4, R3, R5, L2, R2, R4, R5, L2, L3, L2, R5, L4, L2, R3, L5, R2, L1, R1, R3, R3, L5, L2, L2, R5";

record Location { x: Int, y: Int };
record Operation { direction: Direction, distance: Int };
type Direction = L | R;
type Orientation = N | E | S | W;
let start = ({ x: 0, y: 0 });

let produceOp = (in) => {
  let intL = stripErr(char("L"));
  let intR = stripErr(char("R"));
  let val = stripErr(listAt(in, 0));
  let dir = match(val) {
    intL => { L },
    intR => { R }
  };
  let distance = posIntStringToInt(listFilter(isDigit, in));
  let yoink = match(dir, distance) {
    (dir, Some(distance)) => { IOk(({ direction: dir, distance: distance })) },
    (dir, None) => { IErr((dir, distance)) }
  };
  yoink
};

let move = (orient, distance) => {
  (pos) => {
    match(orient) {
      N => { ({ x: pos.x, y: pos.y + distance }) },
      E => { ({ x: pos.x + distance, y: pos.y }) },
      S => { ({ x: pos.x, y: pos.y - distance }) },
      W => { ({ x: pos.x - distance, y: pos.y }) }
    }
  }
};
let rec walker = (opList, orient, location) => {
  let (op, opList2) = stripErr(listUncons(opList));
  let newOrient = match((op.direction, orient)) {
    (L, N) => { W },
    (L, E) => { N },
    (L, S) => { E },
    (L, W) => { S },
    (R, N) => { E },
    (R, E) => { S },
    (R, S) => { W },
    (R, W) => { N }
  };
  let amount = op.distance;
  let newLoc = move(newOrient, amount)(location);
  match(listLength(opList2) > 0) {
    true => { walker(opList2, newOrient, newLoc) },
    false => { newLoc }
  }
};

let rec yoink = (infectedList) => {
  match(listUncons(infectedList)) {
    IOk((head, tail)) => {
      match(head, yoink(tail)) {
        (IOk(value), IOk(restList)) => { IOk(Link(value, restList)) },
        (IErr(err), _) => { IErr(err) },
        (_, IErr(err)) => { IErr(err) }
      }
    },
    IErr(_) => { IOk(Empty) }
  }
};

let process = (in) => {
  let str = stringToList(in);
  let opStrList = listSplitBy(str, char(","));
  let opList = listMap(produceOp, opStrList);
  let cleanOpList = stripErr(yoink(opList));
  let finalLoc = walker(cleanOpList, N, start);
  abs(finalLoc.x) + abs(finalLoc.y)
};

let main = () => {
  print(process(input));
}