from "std/list" import { listSlice, listFilter, listAt, listTake, listLength, listTakeUntil, listSplitBy, listMap, listUncons, listFoldr };
from "std/string" import { isDigit, charCToString, char, posIntStringToInt };
from "std/nativeString" import { stringToList, stringConcat, intToString };
from "std/result" import { stripErr };

let input = "L1, R3, R1, L5";

record Location { x: Int, y: Int };
record Operation { direction: Direction, distance: Int };
type Direction = L | R;
type Orientation = N | E | S | W;
let start = ({ x: 0, y: 0 });

let produceOp = (in) => {
  let intL = char("L");
  let intR = char("R");
  let dir = match(listAt(in, 0)) {
    intL => { L },
    intR => { R }
  };
  let num = posIntStringToInt(listFilter(isDigit, in));
  let yoink = match(dir, num) {
    (IOk(dir), IOk(num)) => { IOk(({ direction: dir, distance: num })) },
    (IErr(dir), IErr(num)) => { IErr((dir, num)) }
  };
  yoink
};

let move = (orient, distance) => {
  (pos) => {
    match(orient) {
      N => { ({ x: pos.x, y: pos.y + distance }) },
      E => { ({ x: pos.x + distance, y: pos.y }) },
      S => { ({ x: pos.x, y: pos.y - distance }) },
      W => { ({ x: pos.x - distance, y: pos.y }) }
    }
  }
};
let rec walker = (opList, orient, location) => {
  let (op, opList2) = stripErr(listUncons(opList));
  let newOrient = match((op.direction, orient)) {
    (L, N) => { W },
    (L, E) => { N },
    (L, S) => { E },
    (L, W) => { S },
    (R, N) => { E },
    (R, E) => { S },
    (R, S) => { W },
    (R, W) => { N }
  };
  print(op);
  let amount = op.distance;
  let newLoc = move(newOrient, amount)(location);
  match(listLength(opList2) > 0) {
    true => { walker(opList2, newOrient, newLoc) },
    false => { newLoc }
  }
};

let rec yoink = (infectedList) => {
  match(listUncons(infectedList)) {
    IOk((head, tail)) => {
      match(head, yoink(tail)) {
        (IOk(value), IOk(restList)) => { IOk(Link(value, restList)) },
        (IErr(err), _) => { IErr(err) },
        (_, IErr(err)) => { IErr(err) }
      }
    },
    IErr(_) => { IOk(Empty) }
  }
};

let process = (in) => {
  let str = stringToList(in);
  let opStrList = listSplitBy(str, char(","));
  let opList = listMap(produceOp, opStrList);
  let cleanOpList = stripErr(yoink(opList));
  let finalLoc = walker(cleanOpList, N, start);
  abs(finalLoc.x) + abs(finalLoc.y)
};

let main = () => {
  print(process(input));
}