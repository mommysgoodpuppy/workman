# Layer 2: Type Hole Inference and Global Solving

This document details the plan for Phase 2 and 3 of the type system evolution: building a global, constraint-based inference engine on top of the marking system from Layer 1.

## 1. Core Components

This layer introduces several new concepts and modules to the codebase.

### 1.1. Constraint Generation (`src/constraints.ts` - New File)

The primary change to the Layer 1 marking system is that it must now also generate a set of constraints.

-   **New Function Signatures:** Every `infer` and `mark` function will have its return signature modified to `(MExpr, Set<Constraint>)`.
-   **Constraint Definition:** A constraint is a simple data structure representing a required unification.
    ```typescript
    // in src/constraints.ts
    import { Type } from './types.ts';
    export type Constraint = { 
      kind: 'eq', 
      typeA: Type, 
      typeB: Type, 
      // Provenance tracks which part of the code generated this constraint
      origin: { file: string, span: SourceSpan } 
    };
    ```
-   **Logic:** Instead of performing unification, the code will now generate constraints. For example, when checking a function call `f(x)`, instead of unifying the type of `f`'s parameter with the type of `x`, we generate a constraint: `{ kind: 'eq', typeA: f.paramType, typeB: x.type, ... }`.

### 1.2. The Solver (`src/solver.ts` - New File)

This is the new engine that performs the global unification.

-   **Input:** A `Set<Constraint>` generated by the marking/constraint-generation pass.
-   **Algorithm:** It will be based on a standard union-find (disjoint set union) data structure, as is common for implementing unification-based inference.
-   **Data Structure:** The solver will maintain a map from `Unknown` type IDs to a `PotentialTypeSet` (as described in the Hazel paper). This structure represents all the information gathered about a particular unknown type.
    ```typescript
    // Simplified example
    type PotentialType = { kind: 'num' } | { kind: 'bool' } | { kind: 'arrow', from: PotentialTypeSet, to: PotentialTypeSet };
    type PotentialTypeSet = {
      id: number;
      potentials: Set<PotentialType>;
      // If this set is unified with another, `parent` points to the canonical set.
      parent?: PotentialTypeSet;
    }
    ```
-   **Output (Success):** If all constraints are consistent, the output is a `Substitution` map (from unknown type IDs to final, concrete `Type`s).
-   **Output (Conflict):** If a conflict is detected (e.g., trying to merge a `PotentialTypeSet` that contains `{kind: 'num'}` with one that contains `{kind: 'bool'}`), the solver does not fail. It records this conflict.

### 1.3. Conflict Resolution and Unfillable Holes

This is the implementation of "Neutral Error Localization."

-   **Conflict Object:** When the solver finds a conflict, it will generate a `Conflict` object.
    ```typescript
    type Conflict = {
      holeProvenance: Provenance; // The original source of the unknown type
      conflictingConstraints: Constraint[]; // The two (or more) constraints that caused the conflict
    }
    ```
-   **Marking Holes:** After the solver runs, the main `inferProgram` function will iterate through any generated `Conflict` objects. For each conflict, it will find the corresponding hole in the `markedAST` (using the provenance information) and update it to an `UnfillableHole` mark.
-   **Partial Solutions:** For each `Conflict`, the system will also generate a set of `RepairAction` objects. Each action represents one possible way to resolve the conflict.
    ```typescript
    type RepairAction = {
      description: string; // e.g., "Make type 'Int'"
      resultingSubstitution: Substitution; // The substitution if this choice is taken
      // The new errors that would be created by applying this substitution
      newlyMarkedNodes: { nodeId: number, mark: MExpr }[]; 
    }
    ```

## 2. Modified `inferProgram` Flow

The top-level function in `src/infer.ts` will orchestrate this entire process.

```typescript
// Simplified new flow for inferProgram
export function inferProgram(program: Program, ...): FinalResult {
  // 1. Run Layer 1: Bidirectional Marking and Constraint Generation
  const { markedAST, constraints } = markAndGenerateConstraints(program);

  // 2. Run Layer 2: Global Constraint Solving
  const { finalSubstitution, conflicts } = solve(constraints);

  // 3. Process Results
  let finalAST = applySubstitutionToAST(markedAST, finalSubstitution);

  const repairSuggestions = [];
  if (conflicts.length > 0) {
    // 4. Mark unfillable holes based on conflicts
    finalAST = markUnfillableHoles(finalAST, conflicts);

    // 5. Generate repair suggestions for the IDE
    for (const conflict of conflicts) {
      repairSuggestions.push(generateRepairActions(conflict));
    }
  }

  // 6. Return everything
  return {
    ast: finalAST,
    summaries: computeSummaries(finalAST),
    suggestions: repairSuggestions,
  };
}
```

This new architecture cleanly separates the concerns of local error marking from global inference, providing a robust foundation for the desired features while maintaining a principled and predictable approach to error localization.
