-- Workman Language Showcase
-- Demonstrating: ADTs, pattern matching, type inference, recursion, and higher-order functions

-- === Custom ADT: Binary Tree ===
type Tree<T> = Leaf | Node<T, Tree<T>, Tree<T>>;

-- Insert into binary search tree
let rec treeInsert = match(tuple) {
  (value, Leaf) => { Node(value, Leaf, Leaf) },
  (value, Node(current, left, right)) => {
    match(cmpInt(value, current)) {
      LT => { Node(current, treeInsert((value, left)), right) },
      EQ => { Node(current, left, right) },
      GT => { Node(current, left, treeInsert((value, right))) }
    }
  }
};

-- Count nodes in tree
let rec treeSize = match(tree) {
  Leaf => { 0 },
  Node(_, left, right) => { add(1, add(treeSize(left), treeSize(right))) }
};

-- Find value in tree
let rec treeContains = match(tuple) {
  (_, Leaf) => { false },
  (value, Node(current, left, right)) => {
    match(cmpInt(value, current)) {
      EQ => { true },
      LT => { treeContains((value, left)) },
      GT => { treeContains((value, right)) }
    }
  }
};

-- === Functional List Operations ===

-- Map with index
let rec mapWithIndex = match(tuple) {
  (_, _, Empty) => { Empty },
  (f, idx, Link(head, tail)) => { Link(f((idx, head)), mapWithIndex((f, add(idx, 1), tail))) }
};

-- Zip two lists together
let rec zipLists = match(tuple) {
  (Empty, _) => { Empty },
  (_, Empty) => { Empty },
  (Link(x, xs), Link(y, ys)) => { Link((x, y), zipLists((xs, ys))) }
};

-- Take first n elements
let rec take = match(tuple) {
  (0, _) => { Empty },
  (_, Empty) => { Empty },
  (n, Link(head, tail)) => { Link(head, take((sub(n, 1), tail))) }
};

-- === Option Combinators ===
let optionChain = (opt1) => {
  (opt2) => {
    match(opt1) {
      Some(v1) => {
        match(opt2) {
          Some(v2) => { Some((v1, v2)) },
          None => { None }
        }
      },
      None => { None }
    }
  }
};

-- === Result Error Handling ===
let resultMap = match(tuple) {
  (f, Ok(value)) => { Ok(f(value)) },
  (_, Err(e)) => { Err(e) }
};

let resultChain = match(tuple) {
  (f, Ok(value)) => { f(value) },
  (_, Err(e)) => { Err(e) }
};

-- Safe division with error handling
let safeDivWithCheck = (a, b) => {
  match(cmpInt(b, 0)) {
    EQ => { Err("Cannot divide by zero") },
    _ => {
      match(cmpInt(a, 0)) {
        LT => { Err("Negative dividend not supported") },
        _ => { Ok(div(a, b)) }
      }
    }
  }
};

-- === Higher-Order Function Utilities ===

-- Flip argument order
let flip = (f) => {
  (a) => {
    (b) => {
      f(b)(a)
    }
  }
};

-- const function (returns first arg, ignores second)
let const = (x) => {
  (_) => {
    x
  }
};

-- Apply function n times
let rec applyN = match(tuple) {
  (0, _, x) => { x },
  (n, f, x) => { applyN((sub(n, 1), f, f(x))) }
};

-- === Test Data and Examples ===

-- Build a sample tree
let sampleTree = () => {
  let t1 = () => {
    treeInsert((5, Leaf))
  };
  let t2 = () => {
    treeInsert((3, t1()))
  };
  let t3 = () => {
    treeInsert((7, t2()))
  };
  let t4 = () => {
    treeInsert((1, t3()))
  };
  treeInsert((9, t4()))
};

-- Test tree operations
let treeNodeCount = () => {
  treeSize(sampleTree())
};
let hasValue7 = () => {
  treeContains((7, sampleTree()))
};
let hasValue10 = () => {
  treeContains((10, sampleTree()))
};

-- Test list operations
let numbers = () => {
  Link(10, Link(20, Link(30, Empty)))
};
let letters = () => {
  Link(1, Link(2, Link(3, Empty)))
};
let zipped = () => {
  zipLists((numbers(), letters()))
};
let firstTwo = () => {
  take((2, numbers()))
};

-- Test option chaining
let opt1 = () => {
  Some(42)
};
let opt2 = () => {
  Some(100)
};
let chained = () => {
  optionChain(opt1())(opt2())
};

-- Test result operations
let goodDiv = () => {
  safeDivWithCheck(10, 2)
};
let badDiv = () => {
  safeDivWithCheck(10, 0)
};

-- Test higher-order functions
let increment = (x) => {
  add(x, 1)
};
let addFive = () => {
  applyN((5, increment, 0))
};
