import { dirname, extname, relative, isAbsolute, toFileUrl } from "std/path/mod.ts";
import type {
  CoreExpr,
  CoreMatchCase,
  CoreModule,
  CoreModuleGraph,
  CorePattern,
  CorePrimOp,
  CoreTypeConstructor,
  CoreTypeDeclaration,
} from "../ir/core.ts";
import { flattenResultType } from "../../../src/types.ts";

interface NameState {
  used: Set<string>;
  counter: number;
}

interface EmitContext {
  state: NameState;
  scope: Map<string, string>;
  runtimeDeps: Map<string, string>;
  extraExports: { local: string; exported: string }[];
  forcedValueExports: Set<string>;
  options: EmitModuleOptions;
}

export interface EmitModuleOptions {
  readonly extension?: string;
  readonly runtimeModule?: string;
  readonly baseDir?: string; // directory of the emitted module file
  readonly forcedValueExports?: readonly string[];
  readonly preludeModule?: {
    specifier: string;
    names: readonly string[];
  };
}

export function emitModule(
  module: CoreModule,
  graph: CoreModuleGraph,
  options: EmitModuleOptions = {},
): string {
  const extension = options.extension ?? ".js";
  const runtimeModule = options.runtimeModule ?? "./runtime.mjs";

  const state: NameState = { used: new Set(), counter: 0 };
  const scope = new Map<string, string>();
  const runtimeDeps = new Map<string, string>();
  const ctx: EmitContext = {
    state,
    scope,
    runtimeDeps,
    extraExports: [],
    forcedValueExports: new Set(options.forcedValueExports ?? []),
    options: { extension, runtimeModule },
  };

  preallocateNames(module, coreGraphImports(module), ctx);

  const lines: string[] = [];
  lines.push("// Generated by Workman compiler");

  const importLines = emitImports(module, graph, ctx);
  if (importLines.length > 0) {
    lines.push(...importLines);
  }
  const preludeImportLines = emitPreludeImports(ctx, options.preludeModule);
  if (preludeImportLines.length > 0) {
    lines.push(...preludeImportLines);
  }
  const runtimeImportIndex = lines.length;

  const typeLines = emitTypeDeclarations(module.typeDeclarations, ctx);
  if (typeLines.length > 0) {
    lines.push(...typeLines);
  }

  for (const binding of module.values) {
    const name = resolveName(ctx.scope, binding.name, ctx.state);
    const expr = emitExpr(binding.value, ctx);
    lines.push(`const ${name} = ${expr};`);
  }

  const exportLine = emitExports(module, ctx);
  if (exportLine) {
    lines.push(exportLine);
  }

  if (runtimeDeps.size > 0) {
    const specifiers = Array.from(runtimeDeps.entries())
      .map(([exported, local]) =>
        exported === local ? exported : `${exported} as ${local}`
      );
    const runtimeImport =
      `import { ${specifiers.join(", ")} } from "${runtimeModule}";`;
    lines.splice(runtimeImportIndex, 0, runtimeImport);
  }

  return `${lines.join("\n")}\n`;
}

function coreGraphImports(module: CoreModule): string[] {
  const names: string[] = [];
  for (const record of module.imports) {
    for (const spec of record.specifiers) {
      names.push(spec.local);
    }
  }
  return names;
}

function preallocateNames(
  module: CoreModule,
  importNames: string[],
  ctx: EmitContext,
): void {
  for (const name of importNames) {
    resolveName(ctx.scope, name, ctx.state);
  }
  for (const decl of module.typeDeclarations) {
    for (const ctor of decl.constructors) {
      resolveName(ctx.scope, ctor.name, ctx.state);
    }
  }
  for (const binding of module.values) {
    resolveName(ctx.scope, binding.name, ctx.state);
  }
}

function emitImports(
  module: CoreModule,
  graph: CoreModuleGraph,
  ctx: EmitContext,
): string[] {
  if (module.imports.length === 0) return [];

  const currentDir = ctx.options.baseDir ?? dirname(module.path);
  const lines: string[] = [];
  for (const entry of module.imports) {
    const specifiers: string[] = [];
    for (const spec of entry.specifiers) {
      const internal = resolveName(ctx.scope, spec.local, ctx.state);
      if (spec.imported === spec.local && spec.imported === internal) {
        specifiers.push(spec.imported);
      } else if (spec.imported === internal) {
        specifiers.push(spec.imported);
      } else {
        specifiers.push(`${spec.imported} as ${internal}`);
      }
    }
    let importPath: string;
    const ext = extname(entry.source).toLowerCase();
    if ((ext === ".js" || ext === ".mjs") && isAbsolute(entry.source)) {
      // Use absolute file URL for external JS so it resolves from emitted temp dir
      importPath = toFileUrl(entry.source).href;
    } else {
      importPath = makeImportPath(
        currentDir,
        entry.source,
        ctx.options.extension ?? ".js",
      );
    }
    lines.push(`import { ${specifiers.join(", ")} } from "${importPath}";`);
  }

  return lines;
}

function emitPreludeImports(
  ctx: EmitContext,
  prelude?: { specifier: string; names: readonly string[] },
): string[] {
  if (!prelude) return [];
  const specifiers: string[] = [];
  for (const name of prelude.names) {
    if (ctx.scope.has(name)) continue;
    const local = resolveName(ctx.scope, name, ctx.state);
    if (local === name) {
      specifiers.push(local);
    } else {
      specifiers.push(`${name} as ${local}`);
    }
  }
  if (specifiers.length === 0) return [];
  return [`import { ${specifiers.join(", ")} } from "${prelude.specifier}";`];
}

function makeImportPath(
  fromDir: string,
  target: string,
  extension: string,
): string {
  let rel = relative(fromDir, target);
  if (rel === "") rel = ".";
  if (!rel.startsWith(".")) {
    rel = `./${rel}`;
  }
  rel = rel.replace(/\\/g, "/");
  const existingExt = extname(rel);
  if (existingExt === "") {
    rel = `${rel}${extension}`;
  } else if (existingExt === ".wm") {
    rel = `${rel.slice(0, rel.length - existingExt.length)}${extension}`;
  }
  return rel;
}

function emitTypeDeclarations(
  declarations: readonly CoreTypeDeclaration[],
  ctx: EmitContext,
): string[] {
  const lines: string[] = [];
  for (const decl of declarations) {
    for (const ctor of decl.constructors) {
      lines.push(...emitConstructor(decl, ctor, ctx));
    }
  }
  return lines;
}

function emitConstructor(
  decl: CoreTypeDeclaration,
  ctor: CoreTypeConstructor,
  ctx: EmitContext,
): string[] {
  const name = resolveName(ctx.scope, ctor.name, ctx.state);
  if (ctor.exported) {
    ctx.extraExports.push({ local: name, exported: ctor.name });
  }
  if (ctor.arity === 0) {
    return [
      `const ${name} = Object.freeze({ tag: "${ctor.name}", type: "${decl.name}" });`,
    ];
  }

  const params = Array.from(
    { length: ctor.arity },
    (_, index) => `arg${index}`,
  );
  const fields = params
    .map((param, index) => `  _${index}: ${param}`)
    .join(",\n");
  const body = fields
    ? `{\n  tag: "${ctor.name}",\n  type: "${decl.name}",\n${fields}\n}`
    : `{\n  tag: "${ctor.name}",\n  type: "${decl.name}"\n}`;
  return [
    `const ${name} = (${params.join(", ")}) => (${body});`,
  ];
}

function emitExports(module: CoreModule, ctx: EmitContext): string | undefined {
  const specifiers: string[] = [];
  const exportedNames = new Set<string>();
  for (const exp of module.exports) {
    if (exp.kind === "type") {
      continue;
    }
    const local = resolveName(
      ctx.scope,
      exp.kind === "value" ? exp.local : exp.ctor,
      ctx.state,
    );
    const exported = exp.kind === "value" ? exp.exported : exp.exported;
    // For operators, the local name is already sanitized, so just export that
    // This avoids trying to export invalid JS identifiers like __op_++
    specifiers.push(local);
    exportedNames.add(exported);
  }
  for (const extra of ctx.extraExports) {
    if (exportedNames.has(extra.exported)) continue;
    if (extra.local === extra.exported) {
      specifiers.push(extra.local);
    } else {
      specifiers.push(`${extra.local} as ${extra.exported}`);
    }
    exportedNames.add(extra.exported);
  }
  for (const forced of ctx.forcedValueExports) {
    if (exportedNames.has(forced)) continue;
    const local = resolveName(ctx.scope, forced, ctx.state);
    // Just export the sanitized local name, don't try to use unsanitized names
    specifiers.push(local);
    exportedNames.add(forced);
  }
  if (specifiers.length === 0) return undefined;
  return `export { ${specifiers.join(", ")} };`;
}

function emitExpr(expr: CoreExpr, ctx: EmitContext): string {
  switch (expr.kind) {
    case "literal":
      return emitLiteral(expr);
    case "var":
      return resolveVar(expr.name, ctx);
    case "tuple":
      return `[${
        expr.elements.map((element) => emitExpr(element, ctx)).join(", ")
      }]`;
    case "record":
      return emitRecord(expr, ctx);
    case "tuple_get":
      return `(${emitExpr(expr.target, ctx)})[${expr.index}]`;
    case "data":
      return emitData(expr, ctx);
    case "lambda":
      return emitLambda(expr, ctx);
    case "call":
      return emitCall(expr, ctx);
    case "let":
      return emitLet(expr, ctx);
    case "let_rec":
      return emitLetRec(expr, ctx);
    case "prim":
      return emitPrim(expr.op, expr.args, ctx);
    case "if":
      return `(${emitExpr(expr.condition, ctx)} ? ${
        emitExpr(expr.thenBranch, ctx)
      } : ${emitExpr(expr.elseBranch, ctx)})`;
    case "match":
      return emitMatch(expr, ctx);
    default:
      throw new CoreLoweringError(
        `Unsupported expression kind '${(expr as CoreExpr).kind}'`,
        expr.origin,
      );
  }
}

function emitLiteral(
  expr: { literal: { kind: string; value?: unknown } },
): string {
  switch (expr.literal.kind) {
    case "unit":
      return "undefined";
    case "int":
    case "char":
      return String(expr.literal.value);
    case "bool":
      return expr.literal.value ? "true" : "false";
    case "string":
      return JSON.stringify(expr.literal.value);
    default:
      throw new Error(`Unsupported literal kind '${expr.literal.kind}'`);
  }
}

function emitRecord(expr: CoreExpr & { kind: "record" }, ctx: EmitContext): string {
  if (expr.fields.length === 0) {
    return "({})";
  }
  const pieces = expr.fields.map((field) => {
    const value = emitExpr(field.value, ctx);
    return `${JSON.stringify(field.name)}: ${value}`;
  }).join(", ");
  return `({ ${pieces} })`;
}

function emitData(expr: CoreExpr & { kind: "data" }, ctx: EmitContext): string {
  const fieldEntries = expr.fields.map((field, index) =>
    `  _${index}: ${emitExpr(field, ctx)}`
  ).join(",\n");
  const fieldBlock = fieldEntries ? `\n${fieldEntries}\n` : "";
  return `({ tag: "${expr.constructor}", type: "${expr.typeName}"${
    fieldBlock ? "," : ""
  }${fieldBlock}})`;
}

function emitLambda(
  expr: CoreExpr & { kind: "lambda" },
  ctx: EmitContext,
): string {
  const handledParams = detectHandledResultParams(expr, expr.params);
  const innerScope = new Map(ctx.scope);
  const params = expr.params.map((param) =>
    resolveName(innerScope, param, ctx.state)
  );
  const body = emitExprWithScope(expr.body, ctx, innerScope);
  const lambda =
    body.includes("\n")
      ? `(${params.join(", ")}) => {\n${indent(`return ${body};`)}\n}`
      : `(${params.join(", ")}) => ${body}`;
  if (handledParams.length > 0) {
    const marker = resolveVar("markResultHandler", ctx);
    return `${marker}(${lambda}, [${handledParams.join(", ")}])`;
  }
  return lambda;
}

function detectHandledResultParams(
  expr: CoreExpr & { kind: "lambda" },
  originalParams: readonly string[],
): number[] {
  if (expr.body.kind !== "match") {
    return [];
  }
  if (expr.body.scrutinee.kind !== "var") {
    return [];
  }
  const paramIndex = originalParams.indexOf(expr.body.scrutinee.name);
  if (paramIndex === -1) {
    return [];
  }
  const hasAllErrors = expr.body.cases.some((kase) =>
    kase.pattern.kind === "all_errors"
  );
  if (!hasAllErrors) {
    return [];
  }
  return [paramIndex];
}

function emitCall(expr: CoreExpr & { kind: "call" }, ctx: EmitContext): string {
  const resultInfo = flattenResultType(expr.type);
  if (!resultInfo) {
    const callee = emitExpr(expr.callee, ctx);
    const args = expr.args.map((arg) => emitExpr(arg, ctx));
    return `(${callee})(${args.join(", ")})`;
  }
  const helper = resolveVar("callInfectious", ctx);
  const segments = [
    emitExpr(expr.callee, ctx),
    ...expr.args.map((arg) => emitExpr(arg, ctx)),
  ];
  return `${helper}(${segments.join(", ")})`;
}

function emitLet(expr: CoreExpr & { kind: "let" }, ctx: EmitContext): string {
  const innerScope = new Map(ctx.scope);
  const bindingName = resolveName(innerScope, expr.binding.name, ctx.state);
  const valueCode = emitExprWithScope(expr.binding.value, ctx, innerScope);
  const bodyCode = emitExprWithScope(expr.body, ctx, innerScope);
  return `(() => {\n${indent(`const ${bindingName} = ${valueCode};`)}\n${
    indent(`return ${bodyCode};`)
  }\n})()`;
}

function emitLetRec(
  expr: CoreExpr & { kind: "let_rec" },
  ctx: EmitContext,
): string {
  const innerScope = new Map(ctx.scope);
  for (const binding of expr.bindings) {
    resolveName(innerScope, binding.name, ctx.state);
  }
  const bindingLines = expr.bindings.map((binding) => {
    const name = innerScope.get(binding.name)!;
    const value = emitExprWithScope(binding.value, ctx, innerScope);
    return `const ${name} = ${value};`;
  });
  const body = emitExprWithScope(expr.body, ctx, innerScope);
  const bodyLine = `return ${body};`;
  const lines = [...bindingLines, bodyLine].map(indent).join("\n");
  return `(() => {\n${lines}\n})()`;
}

function emitMatch(
  expr: CoreExpr & { kind: "match" },
  ctx: EmitContext,
): string {
  const scrutineeCode = emitExpr(expr.scrutinee, ctx);
  const scrutineeTemp = allocateTempName(ctx.state, "__match_scrutinee");
  const baseScope = new Map(ctx.scope);
  const lines: string[] = [];
  lines.push(`const ${scrutineeTemp} = ${scrutineeCode};`);
  for (const kase of expr.cases) {
    lines.push(...emitMatchCase(kase, scrutineeTemp, ctx, baseScope));
  }
  if (expr.fallback) {
    const fallbackExpr = emitExprWithScope(
      expr.fallback,
      ctx,
      new Map(ctx.scope),
    );
    lines.push(`return ${fallbackExpr};`);
  } else {
    lines.push(
      `throw new Error("Non-exhaustive patterns at runtime");`,
    );
  }
  const body = lines.map((line) => indent(line)).join("\n");
  return `(() => {\n${body}\n})()`;
}

function emitMatchCase(
  kase: CoreMatchCase,
  scrutineeRef: string,
  ctx: EmitContext,
  baseScope: Map<string, string>,
): string[] {
  const caseScope = new Map(baseScope);
  const { conditions, bindings } = emitPattern(
    kase.pattern,
    scrutineeRef,
    ctx,
    caseScope,
  );
  const conditionExpr = conditions.length > 0
    ? conditions.map((cond) => `(${cond})`).join(" && ")
    : "true";
  const guardExpr = kase.guard
    ? emitExprWithScope(kase.guard, ctx, caseScope)
    : undefined;
  const bodyExpr = emitExprWithScope(kase.body, ctx, caseScope);

  const lines: string[] = [];
  lines.push(`if (${conditionExpr}) {`);

  const innerLines: string[] = [];
  innerLines.push(...bindings);
  if (guardExpr) {
    innerLines.push(`if (${guardExpr}) {`);
    innerLines.push(indent(`return ${bodyExpr};`));
    innerLines.push(`}`);
  } else {
    innerLines.push(`return ${bodyExpr};`);
  }

  lines.push(...innerLines.map((line) => indent(line)));
  lines.push(`}`);
  return lines;
}

interface PatternEmission {
  conditions: string[];
  bindings: string[];
}

function emitPattern(
  pattern: CorePattern,
  valueRef: string,
  ctx: EmitContext,
  scope: Map<string, string>,
): PatternEmission {
  const ref = `(${valueRef})`;
  switch (pattern.kind) {
    case "wildcard":
      return { conditions: [], bindings: [] };
    case "binding": {
      const name = resolveName(scope, pattern.name, ctx.state);
      return {
        conditions: [],
        bindings: [`const ${name} = ${ref};`],
      };
    }
    case "literal": {
      const literalExpr = emitLiteral({ literal: pattern.literal });
      return {
        conditions: [`${ref} === ${literalExpr}`],
        bindings: [],
      };
    }
    case "tuple": {
      const length = pattern.elements.length;
      const conditions = [
        `Array.isArray(${ref})`,
        `${ref}.length === ${length}`,
      ];
      const bindings: string[] = [];
      for (let index = 0; index < length; index += 1) {
        const nested = emitPattern(
          pattern.elements[index],
          `${ref}[${index}]`,
          ctx,
          scope,
        );
        conditions.push(...nested.conditions);
        bindings.push(...nested.bindings);
      }
      return { conditions, bindings };
    }
    case "constructor": {
      const conditions = [
        `${ref}?.tag === "${pattern.constructor}"`,
        `${ref}?.type === "${pattern.typeName}"`,
      ];
      const bindings: string[] = [];
      for (let index = 0; index < pattern.fields.length; index += 1) {
        const nested = emitPattern(
          pattern.fields[index],
          `${ref}._${index}`,
          ctx,
          scope,
        );
        conditions.push(...nested.conditions);
        bindings.push(...nested.bindings);
      }
      return { conditions, bindings };
    }
    case "all_errors": {
      return {
        conditions: [
          `${ref}?.tag === "Err"`,
          `${ref}?.type === "${pattern.resultTypeName}"`,
        ],
        bindings: [],
      };
    }
    default: {
      const _exhaustive: never = pattern;
      void _exhaustive;
      throw new CoreLoweringError(
        `Unsupported pattern kind '${(pattern as CorePattern).kind}'`,
        pattern.origin,
      );
    }
  }
}

function emitExprWithScope(
  expr: CoreExpr,
  ctx: EmitContext,
  scope: Map<string, string>,
): string {
  const previous = ctx.scope;
  ctx.scope = scope;
  try {
    return emitExpr(expr, ctx);
  } finally {
    ctx.scope = previous;
  }
}

function emitPrim(op: CorePrimOp, args: CoreExpr[], ctx: EmitContext): string {
  const emitArg = (index: number) => emitExpr(args[index], ctx);
  switch (op) {
    case "int_add":
      return `(${emitArg(0)} + ${emitArg(1)})`;
    case "int_sub":
      return `(${emitArg(0)} - ${emitArg(1)})`;
    case "int_mul":
      return `(${emitArg(0)} * ${emitArg(1)})`;
    case "int_div":
      return `Math.trunc(${emitArg(0)} / ${emitArg(1)})`;
    case "int_eq":
      return `(${emitArg(0)} === ${emitArg(1)})`;
    case "int_ne":
      return `(${emitArg(0)} !== ${emitArg(1)})`;
    case "int_lt":
      return `(${emitArg(0)} < ${emitArg(1)})`;
    case "int_le":
      return `(${emitArg(0)} <= ${emitArg(1)})`;
    case "int_gt":
      return `(${emitArg(0)} > ${emitArg(1)})`;
    case "int_ge":
      return `(${emitArg(0)} >= ${emitArg(1)})`;
    case "int_cmp": {
      const cmp = resolveVar("nativeCmpInt", ctx);
      return `${cmp}(${emitArg(0)}, ${emitArg(1)})`;
    }
    case "bool_and":
      return `(${emitArg(0)} && ${emitArg(1)})`;
    case "bool_or":
      return `(${emitArg(0)} || ${emitArg(1)})`;
    case "bool_not":
      return `(!${emitArg(0)})`;
    case "char_eq":
      return `(${emitArg(0)} === ${emitArg(1)})`;
    case "string_length":
      return `${emitArg(0)}.length`;
    case "string_slice":
      return `${emitArg(0)}.slice(${emitArg(1)}, ${emitArg(2)})`;
    case "native_print": {
      const fn = resolveVar("nativePrint", ctx);
      return `${fn}(${emitArg(0)})`;
    }
    case "record_get": {
      const target = emitArg(0);
      const field = args[1];
      if (field.kind !== "literal" || field.literal.kind !== "string") {
        throw new Error("record_get expects string literal field");
      }
      const fieldName = JSON.stringify(field.literal.value);
      return `(${target})[${fieldName}]`;
    }
    default:
      throw new CoreLoweringError(
        `Unsupported primitive op '${op}'`,
        undefined,
      );
  }
}

function resolveVar(name: string, ctx: EmitContext): string {
  if (ctx.scope.has(name)) {
    return ctx.scope.get(name)!;
  }
  if (!ctx.runtimeDeps.has(name)) {
    ctx.runtimeDeps.set(name, sanitizeIdentifier(name, ctx.state));
  }
  const alias = ctx.runtimeDeps.get(name)!;
  ctx.scope.set(name, alias);
  return alias;
}

function resolveName(
  scope: Map<string, string>,
  original: string,
  state: NameState,
): string {
  if (scope.has(original)) {
    return scope.get(original)!;
  }
  const sanitized = sanitizeIdentifier(original, state);
  scope.set(original, sanitized);
  return sanitized;
}

const RESERVED = new Set<string>([
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "export",
  "extends",
  "finally",
  "for",
  "function",
  "if",
  "import",
  "in",
  "instanceof",
  "new",
  "return",
  "super",
  "switch",
  "this",
  "throw",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield",
  "enum",
  "await",
  "implements",
  "package",
  "protected",
  "static",
  "interface",
  "private",
  "public",
]);

function sanitizeIdentifier(name: string, state: NameState): string {
  const base = makeIdentifierBase(name);
  let candidate = base;
  while (RESERVED.has(candidate) || state.used.has(candidate)) {
    candidate = `${base}_${state.counter++}`;
  }
  state.used.add(candidate);
  return candidate;
}

function allocateTempName(state: NameState, base: string): string {
  return sanitizeIdentifier(base, state);
}

function makeIdentifierBase(name: string): string {
  const cleaned = name.replace(/[^A-Za-z0-9_$]/g, "_");
  if (/^[A-Za-z_$]/.test(cleaned)) {
    return cleaned;
  }
  return `_${cleaned || "name"}`;
}

function indent(text: string): string {
  return text.split("\n").map((line) => (line.length > 0 ? `  ${line}` : line))
    .join("\n");
}

export class CoreLoweringError extends Error {
  constructor(message: string, public readonly nodeId?: number) {
    super(message);
    this.name = "CoreLoweringError";
  }
}
