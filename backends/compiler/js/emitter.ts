import {
  dirname,
  extname,
  isAbsolute,
  relative,
  toFileUrl,
} from "../../../src/io.ts";
import type {
  CoreExpr,
  CoreLiteral,
  CoreMatchCase,
  CoreModule,
  CoreModuleGraph,
  CorePattern,
  CorePrimOp,
  CoreTypeConstructor,
  CoreTypeDeclaration,
} from "../ir/core.ts";
import {
  findCarrierDomain,
  flattenResultType,
  isCarrierType,
} from "../../../src/types.ts";

interface NameState {
  used: Set<string>;
  counter: number;
}

interface EmitContext {
  state: NameState;
  scope: Map<string, string>;
  runtimeDeps: Map<string, string>;
  extraExports: { local: string; exported: string }[];
  forcedValueExports: Set<string>;
  options: EmitModuleOptions;
  modulePath: string;
}

export interface EmitModuleOptions {
  readonly extension?: string;
  readonly runtimeModule?: string;
  readonly baseDir?: string; // directory of the emitted module file
  readonly forcedValueExports?: readonly string[];
  readonly preludeModule?: {
    specifier: string;
    names: readonly string[];
  };
  readonly invokeEntrypoint?: boolean;
}

const PRELUDE_OPERATOR_ALIASES = new Map<string, string>([
  ["__op_+", "add"],
  ["__op_-", "sub"],
  ["__op_*", "mul"],
  ["__op_/", "div"],
  ["__op_==", "eq"],
  ["__op_!=", "neq"],
  ["__op_<", "lt"],
  ["__op_>", "gt"],
  ["__op_<=", "lte"],
  ["__op_>=", "gte"],
  ["__op_&&", "boolAnd"],
  ["__op_||", "boolOr"],
]);

const PRELUDE_PREFIX_ALIASES = new Map<string, string>([
  ["__prefix_!", "not"],
]);

export function emitModule(
  module: CoreModule,
  graph: CoreModuleGraph,
  options: EmitModuleOptions = {},
): string {
  const extension = options.extension ?? ".js";
  const runtimeModule = options.runtimeModule ?? "./runtime.mjs";

  const state: NameState = { used: new Set(), counter: 0 };
  const scope = new Map<string, string>();
  const runtimeDeps = new Map<string, string>();
  const ctx: EmitContext = {
    state,
    scope,
    runtimeDeps,
    extraExports: [],
    forcedValueExports: new Set(options.forcedValueExports ?? []),
    options: { extension, runtimeModule },
    modulePath: module.path,
  };

  preallocateNames(module, coreGraphImports(module), ctx);

  const lines: string[] = [];
  lines.push("// Generated by Workman compiler");

  const importLines = emitImports(module, graph, ctx);
  if (importLines.length > 0) {
    lines.push(...importLines);
  }
  const preludeImportLines = emitPreludeImports(ctx, options.preludeModule);
  if (preludeImportLines.length > 0) {
    lines.push(...preludeImportLines);
  }
  const runtimeImportIndex = lines.length;

  const typeLines = emitTypeDeclarations(module.typeDeclarations, ctx);
  if (typeLines.length > 0) {
    lines.push(...typeLines);
  }

  for (const binding of module.values) {
    const name = resolveName(ctx.scope, binding.name, ctx.state);
    const expr = emitExpr(binding.value, ctx);
    lines.push(`const ${name} = ${expr};`);
  }

  const exportLine = emitExports(module, ctx);
  if (exportLine) {
    lines.push(exportLine);
  }

  if (runtimeDeps.size > 0) {
    const specifiers = Array.from(runtimeDeps.entries())
      .map(([exported, local]) =>
        exported === local ? exported : `${exported} as ${local}`
      );
    const runtimeImport = `import { ${
      specifiers.join(", ")
    } } from "${runtimeModule}";`;
    lines.splice(runtimeImportIndex, 0, runtimeImport);
  }

  // Auto-call main if it's the entry module and main is exported
  if (module.path === graph.entry && (options.invokeEntrypoint ?? true)) {
    const mainExport = module.exports.find(
      (exp) => exp.kind === "value" && exp.exported === "main",
    );
    const mainForced = ctx.forcedValueExports.has("main");

    if (mainExport || mainForced) {
      lines.push("");
      lines.push(`if (typeof main !== "undefined") { main(); }`);
    }
  }

  return `${lines.join("\n")}\n`;
}

function coreGraphImports(module: CoreModule): string[] {
  const names: string[] = [];
  for (const record of module.imports) {
    for (const spec of record.specifiers) {
      names.push(spec.local);
    }
  }
  return names;
}

function preallocateNames(
  module: CoreModule,
  importNames: string[],
  ctx: EmitContext,
): void {
  for (const name of importNames) {
    resolveName(ctx.scope, name, ctx.state);
  }
  for (const decl of module.typeDeclarations) {
    for (const ctor of decl.constructors) {
      resolveName(ctx.scope, ctor.name, ctx.state);
    }
  }
  for (const binding of module.values) {
    resolveName(ctx.scope, binding.name, ctx.state);
  }
}

function emitImports(
  module: CoreModule,
  graph: CoreModuleGraph,
  ctx: EmitContext,
): string[] {
  if (module.imports.length === 0) return [];

  const currentDir = ctx.options.baseDir ?? dirname(module.path);
  const lines: string[] = [];
  for (const entry of module.imports) {
    const specifiers: string[] = [];
    for (const spec of entry.specifiers) {
      const internal = resolveName(ctx.scope, spec.local, ctx.state);
      if (spec.imported === spec.local && spec.imported === internal) {
        specifiers.push(spec.imported);
      } else if (spec.imported === internal) {
        specifiers.push(spec.imported);
      } else {
        specifiers.push(`${spec.imported} as ${internal}`);
      }
    }
    let importPath: string;
    const ext = extname(entry.source).toLowerCase();
    if ((ext === ".js" || ext === ".mjs") && isAbsolute(entry.source)) {
      // Use absolute file URL for external JS so it resolves from emitted temp dir
      importPath = toFileUrl(entry.source).href;
    } else {
      importPath = makeImportPath(
        currentDir,
        entry.source,
        ctx.options.extension ?? ".js",
      );
    }
    if (specifiers.length === 0) {
      // Side-effect import (no specifiers)
      lines.push(`import "${importPath}";`);
    } else {
      lines.push(`import { ${specifiers.join(", ")} } from "${importPath}";`);
    }
  }

  return lines;
}

function emitPreludeImports(
  ctx: EmitContext,
  prelude?: { specifier: string; names: readonly string[] },
): string[] {
  if (!prelude) return [];
  const specifiers: string[] = [];
  for (const name of prelude.names) {
    if (ctx.scope.has(name)) continue;
    const local = resolveName(ctx.scope, name, ctx.state);
    if (local === name) {
      specifiers.push(local);
    } else {
      specifiers.push(`${name} as ${local}`);
    }
  }
  if (specifiers.length === 0) return [];
  return [`import { ${specifiers.join(", ")} } from "${prelude.specifier}";`];
}

function makeImportPath(
  fromDir: string,
  target: string,
  extension: string,
): string {
  let rel = relative(fromDir, target);
  if (rel === "") rel = ".";
  if (!rel.startsWith(".")) {
    rel = `./${rel}`;
  }
  rel = rel.replace(/\\/g, "/");
  const existingExt = extname(rel);
  if (existingExt === "") {
    rel = `${rel}${extension}`;
  } else if (existingExt === ".wm") {
    rel = `${rel.slice(0, rel.length - existingExt.length)}${extension}`;
  }
  return rel;
}

function emitTypeDeclarations(
  declarations: readonly CoreTypeDeclaration[],
  ctx: EmitContext,
): string[] {
  const lines: string[] = [];
  for (const decl of declarations) {
    // Emit constructors
    for (const ctor of decl.constructors) {
      lines.push(...emitConstructor(decl, ctor, ctx));
    }

    // Emit infectious type registration if this is an infectious type
    if (
      decl.infectious && decl.infectious.valueConstructor &&
      decl.infectious.effectConstructors
    ) {
      const registerFn = resolveVar("registerInfectiousType", ctx);
      const effectCtorsArray = `[${
        decl.infectious.effectConstructors.map((c) => `"${c}"`).join(", ")
      }]`;
      lines.push(
        `${registerFn}("${decl.name}", "${decl.infectious.valueConstructor}", ${effectCtorsArray});`,
      );
    }
  }
  return lines;
}

function emitConstructor(
  decl: CoreTypeDeclaration,
  ctor: CoreTypeConstructor,
  ctx: EmitContext,
): string[] {
  const name = resolveName(ctx.scope, ctor.name, ctx.state);
  if (ctor.exported) {
    const sanitized = makeIdentifierBase(ctor.name);
    ctx.extraExports.push({ local: name, exported: sanitized });
  }
  if (ctor.arity === 0) {
    return [
      `const ${name} = Object.freeze({ tag: "${ctor.name}", type: "${decl.name}" });`,
    ];
  }

  const params = Array.from(
    { length: ctor.arity },
    (_, index) => `arg${index}`,
  );
  const fields = params
    .map((param, index) => `  _${index}: ${param}`)
    .join(",\n");
  const body = fields
    ? `{\n  tag: "${ctor.name}",\n  type: "${decl.name}",\n${fields}\n}`
    : `{\n  tag: "${ctor.name}",\n  type: "${decl.name}"\n}`;
  return [
    `const ${name} = (${params.join(", ")}) => (${body});`,
  ];
}

function emitExports(module: CoreModule, ctx: EmitContext): string | undefined {
  const specifiers: string[] = [];
  const exportedNames = new Set<string>();
  for (const exp of module.exports) {
    if (exp.kind === "type") {
      continue;
    }
    const local = exp.kind === "value"
      ? resolveName(ctx.scope, exp.local, ctx.state)
      : exp.exported; // For constructors, exported is already sanitized
    // For operators, the local name is already sanitized, so just export that
    // This avoids trying to export invalid JS identifiers like __op_++'
    specifiers.push(local);
    exportedNames.add(exp.exported);
  }
  for (const extra of ctx.extraExports) {
    if (exportedNames.has(extra.exported)) continue;
    if (extra.local === extra.exported) {
      specifiers.push(extra.local);
    } else {
      specifiers.push(`${extra.local} as ${extra.exported}`);
    }
    exportedNames.add(extra.exported);
  }
  for (const forced of ctx.forcedValueExports) {
    if (exportedNames.has(forced)) continue;
    const local = resolveName(ctx.scope, forced, ctx.state);
    // Just export the sanitized local name, don't try to use unsanitized names
    specifiers.push(local);
    exportedNames.add(forced);
  }
  if (specifiers.length === 0) return undefined;
  return `export { ${specifiers.join(", ")} };`;
}

function emitExpr(expr: CoreExpr, ctx: EmitContext): string {
  switch (expr.kind) {
    case "literal":
      return emitLiteral(expr, ctx);
    case "var":
      return resolveVar(expr.name, ctx);
    case "tuple":
      return `[${
        expr.elements.map((element) => emitExpr(element, ctx)).join(", ")
      }]`;
    case "record":
      return emitRecord(expr, ctx);
    case "tuple_get":
      return `(${emitExpr(expr.target, ctx)})[${expr.index}]`;
    case "data":
      return emitData(expr, ctx);
    case "lambda":
      return emitLambda(expr, ctx);
    case "call":
      return emitCall(expr, ctx);
    case "let":
      return emitLet(expr, ctx);
    case "let_rec":
      return emitLetRec(expr, ctx);
    case "prim":
      return emitPrim(expr.op, expr.args, ctx);
    case "if":
      return `(${emitExpr(expr.condition, ctx)} ? ${
        emitExpr(expr.thenBranch, ctx)
      } : ${emitExpr(expr.elseBranch, ctx)})`;
    case "match":
      const matchCode = emitMatch(expr, ctx);
      if (isCarrierType(expr.scrutinee.type)) {
        const scrutineeDomain = findCarrierDomain(expr.scrutinee.type);
        if (scrutineeDomain === "async") {
          // Async matches are fully handled inside matchPromise
          return matchCode;
        }
        const scrutineeCode = emitExpr(expr.scrutinee, ctx);
        if (expr.effectRowCoverage?.dischargesResult) {
          return `(${matchCode})(${scrutineeCode})`;
        }
        const helper = resolveVar("callInfectious", ctx);
        return `${helper}(${matchCode}, ${scrutineeCode})`;
      }
      return matchCode;
    default:
      throw new CoreLoweringError(
        `Unsupported expression kind '${(expr as CoreExpr).kind}'`,
      );
  }
}

function emitLiteral(
  expr: { literal: { kind: string; value?: unknown } },
  ctx: EmitContext,
): string {
  switch (expr.literal.kind) {
    case "unit":
      return "undefined";
    case "int":
    case "char":
      return String(expr.literal.value);
    case "bool":
      return expr.literal.value ? "true" : "false";
    case "string": {
      // String literals now desugar to native String type
      const fn = resolveVar("nativeStringFromLiteral", ctx);
      return `${fn}(${JSON.stringify(expr.literal.value)})`;
    }
    default:
      throw new Error(`Unsupported literal kind '${expr.literal.kind}'`);
  }
}

function emitRecord(
  expr: CoreExpr & { kind: "record" },
  ctx: EmitContext,
): string {
  if (expr.fields.length === 0) {
    return "({})";
  }
  const pieces = expr.fields.map((field) => {
    const value = emitExpr(field.value, ctx);
    return `${JSON.stringify(field.name)}: ${value}`;
  }).join(", ");
  return `({ ${pieces} })`;
}

function emitData(expr: CoreExpr & { kind: "data" }, ctx: EmitContext): string {
  if (expr.typeName === "Result" && expr.constructor === "Ok") {
    const wrapper = resolveVar("wrapResultValue", ctx);
    const value = expr.fields.length > 0
      ? emitExpr(expr.fields[0], ctx)
      : "undefined";
    return `${wrapper}(${value})`;
  }

  // Optimization: Reuse existing constants for 0-arity constructors
  if (expr.fields.length === 0) {
    // Check if the constructor name is available in scope and not shadowed/renamed
    if (ctx.scope.has(expr.constructor)) {
      const mapped = ctx.scope.get(expr.constructor);
      if (mapped === expr.constructor) {
        return mapped;
      }
    }
  }

  const fieldEntries = expr.fields.map((field, index) =>
    `  _${index}: ${emitExpr(field, ctx)}`
  ).join(",\n");
  const fieldBlock = fieldEntries ? `\n${fieldEntries}\n` : "";
  return `({ tag: "${expr.constructor}", type: "${expr.typeName}"${
    fieldBlock ? "," : ""
  }${fieldBlock}})`;
}

function emitLambda(
  expr: CoreExpr & { kind: "lambda" },
  ctx: EmitContext,
): string {
  const handledParams = detectHandledResultParams(expr, expr.params);
  const innerScope = new Map(ctx.scope);
  const params = expr.params.map((param) =>
    resolveName(innerScope, param, ctx.state)
  );
  const body = emitExprWithScope(expr.body, ctx, innerScope);
  const lambda = body.includes("\n")
    ? `(${params.join(", ")}) => {\n${indent(`return ${body};`)}\n}`
    : `(${params.join(", ")}) => ${body}`;
  if (handledParams.length > 0) {
    const marker = resolveVar("markResultHandler", ctx);
    return `${marker}(${lambda}, [${handledParams.join(", ")}])`;
  }
  return lambda;
}

function detectHandledResultParams(
  expr: CoreExpr & { kind: "lambda" },
  originalParams: readonly string[],
): number[] {
  const directMatch = resolveMatchInLambda(expr.body, originalParams);
  if (directMatch) {
    const { matchExpr, paramIndex } = directMatch;
    if (paramIndex !== -1) {
      const hasResultPatterns = matchExpr.cases.some((c) =>
        hasResultConstructorPattern(c.pattern)
      );
      if (hasResultPatterns) {
        return [paramIndex];
      }
      const coverage = matchExpr.effectRowCoverage;
      if (coverage?.dischargesResult) {
        return [paramIndex];
      }
    }
  }

  // Handle tuple of parameters: match((param1, param2)) { (_, Ok(...)) => ... }
  if (expr.body.kind === "match" && expr.body.scrutinee.kind === "tuple") {
    const handledIndices: number[] = [];

    // Check each pattern to see which tuple positions have Result constructors
    for (const matchCase of expr.body.cases) {
      if (matchCase.pattern.kind === "tuple") {
        for (let i = 0; i < matchCase.pattern.elements.length; i++) {
          const element = matchCase.pattern.elements[i];
          if (hasResultConstructorPattern(element)) {
            // Find which parameter this tuple position corresponds to
            const scrutineeElement = expr.body.scrutinee.elements[i];
            if (scrutineeElement?.kind === "var") {
              const paramIndex = originalParams.indexOf(scrutineeElement.name);
              if (paramIndex !== -1 && !handledIndices.includes(paramIndex)) {
                handledIndices.push(paramIndex);
              }
            }
          }
        }
      }
    }

    if (handledIndices.length > 0) {
      return handledIndices;
    }

    // Fall back to checking if any element variables are in the param list
    const coverage = expr.body.effectRowCoverage;
    if (coverage?.dischargesResult) {
      for (const element of expr.body.scrutinee.elements) {
        if (element.kind === "var") {
          const paramIndex = originalParams.indexOf(element.name);
          if (paramIndex !== -1) {
            handledIndices.push(paramIndex);
          }
        }
      }
      return handledIndices;
    }
  }

  return [];
}

function resolveMatchInLambda(
  body: CoreExpr,
  params: readonly string[],
): { matchExpr: CoreExpr & { kind: "match" }; paramIndex: number } | null {
  if (body.kind === "match" && body.scrutinee.kind === "var") {
    const paramIndex = params.indexOf(body.scrutinee.name);
    if (paramIndex === -1) return null;
    return { matchExpr: body, paramIndex };
  }
  if (
    body.kind === "call" && body.args.length === 1 &&
    body.args[0].kind === "var" && body.callee.kind === "match"
  ) {
    const paramIndex = params.indexOf(body.args[0].name);
    if (paramIndex === -1) return null;
    return { matchExpr: body.callee, paramIndex };
  }
  return null;
}

// Helper to check if a pattern contains Ok or Err constructors
function hasResultConstructorPattern(pattern: CorePattern): boolean {
  switch (pattern.kind) {
    case "constructor":
      return isCarrierType(pattern.type);
    case "tuple":
      return pattern.elements.some(hasResultConstructorPattern);
    case "wildcard":
    case "binding":
    case "literal":
    case "all_errors":
      return false;
  }
}

function emitCall(expr: CoreExpr & { kind: "call" }, ctx: EmitContext): string {
  const callExpr = emitCallInternal(expr, ctx);
  const tracker = resolveVar("withCallSite", ctx);
  const metadataLiteral = serializeNodeMetadata(expr, ctx);
  return `${tracker}(${metadataLiteral}, () => (${callExpr}))`;
}

function emitCallInternal(
  expr: CoreExpr & { kind: "call" },
  ctx: EmitContext,
): string {
  // Check if the result, callee, or any argument has an infectious type
  const resultIsInfectious = isCarrierType(expr.type);
  const calleeIsInfectious = isCarrierType(expr.callee.type);
  const anyArgIsInfectious = expr.args.some((arg) => isCarrierType(arg.type));

  const needsInfectiousCall = resultIsInfectious || calleeIsInfectious ||
    anyArgIsInfectious;

  if (!needsInfectiousCall) {
    const callee = emitExpr(expr.callee, ctx);
    const args = expr.args.map((arg) => emitExpr(arg, ctx));
    return `(${callee})(${args.join(", ")})`;
  }

  // Check if we need async handling (Promise)
  const isAsync = findCarrierDomain(expr.type) === "async" ||
    findCarrierDomain(expr.callee.type) === "async" ||
    expr.args.some((arg) => findCarrierDomain(arg.type) === "async");

  if (isAsync) {
    const helper = resolveVar("callAsync", ctx);
    const segments = [
      emitExpr(expr.callee, ctx),
      ...expr.args.map((arg) => emitExpr(arg, ctx)),
    ];
    return `${helper}(${segments.join(", ")})`;
  }

  const helper = resolveVar("callInfectious", ctx);
  const segments = [
    emitExpr(expr.callee, ctx),
    ...expr.args.map((arg) => emitExpr(arg, ctx)),
  ];
  return `${helper}(${segments.join(", ")})`;
}

function emitLet(expr: CoreExpr & { kind: "let" }, ctx: EmitContext): string {
  const innerScope = new Map(ctx.scope);
  const bindingName = resolveName(innerScope, expr.binding.name, ctx.state);
  let valueCode = emitExprWithScope(expr.binding.value, ctx, innerScope);
  if (
    expr.binding.value.kind === "lambda" &&
    expr.binding.value.params.length === 1 &&
    expr.binding.value.params[0] === "res"
  ) {
    valueCode = `(${valueCode})(res)`;
  }
  const bodyCode = emitExprWithScope(expr.body, ctx, innerScope);
  return `(() => {\n${indent(`const ${bindingName} = ${valueCode};`)}\n${
    indent(`return ${bodyCode};`)
  }\n})()`;
}

function emitLetRec(
  expr: CoreExpr & { kind: "let_rec" },
  ctx: EmitContext,
): string {
  const innerScope = new Map(ctx.scope);
  for (const binding of expr.bindings) {
    resolveName(innerScope, binding.name, ctx.state);
  }
  const bindingLines = expr.bindings.map((binding) => {
    const name = innerScope.get(binding.name)!;
    const value = emitExprWithScope(binding.value, ctx, innerScope);
    return `const ${name} = ${value};`;
  });
  const body = emitExprWithScope(expr.body, ctx, innerScope);
  const bodyLine = `return ${body};`;
  const lines = [...bindingLines, bodyLine].map(indent).join("\n");
  return `(() => {\n${lines}\n})()`;
}

function emitMatch(
  expr: CoreExpr & { kind: "match" },
  ctx: EmitContext,
): string {
  const scrutineeIsCarrier = isCarrierType(expr.scrutinee.type);

  if (findCarrierDomain(expr.scrutinee.type) === "async") {
    const helper = resolveVar("matchPromise", ctx);
    const paramName = allocateTempName(ctx.state, "__match_async_val");
    const innerScope = new Map(ctx.scope);

    const lines: string[] = [];
    for (const kase of expr.cases) {
      lines.push(...emitMatchCase(kase, paramName, ctx, innerScope));
    }

    if (expr.fallback) {
      const fallbackExpr = emitExprWithScope(
        expr.fallback,
        ctx,
        innerScope,
      );
      lines.push(`return ${fallbackExpr};`);
    } else {
      const helper = resolveVar("nonExhaustiveMatch", ctx);
      const metadataLiteral = serializeMatchMetadata(expr, ctx);
      lines.push(`${helper}(${paramName}, ${metadataLiteral});`);
    }

    const body = lines.map((line) => indent(line)).join("\n");
    const matcher = `(${paramName}) => {\n${body}\n}`;

    const scrutineeCode = emitExpr(expr.scrutinee, ctx);
    return `${helper}(${scrutineeCode}, ${matcher})`;
  }

  const dischargesCarrier = Boolean(expr.effectRowCoverage?.dischargesResult);
  const patternsHandleCarrier = expr.cases.some((kase) =>
    hasResultConstructorPattern(kase.pattern) ||
    kase.pattern.kind === "all_errors"
  );
  if (scrutineeIsCarrier && dischargesCarrier && patternsHandleCarrier) {
    const paramName = allocateTempName(ctx.state, "res");
    const innerScope = new Map(ctx.scope);
    innerScope.set("res", paramName);
    const scrutineeTemp = allocateTempName(ctx.state, "__match_scrutinee");
    const lines: string[] = [];
    lines.push(`const ${scrutineeTemp} = ${paramName};`);
    for (const kase of expr.cases) {
      lines.push(...emitMatchCase(kase, scrutineeTemp, ctx, innerScope));
    }
    if (expr.fallback) {
      const fallbackExpr = emitExprWithScope(
        expr.fallback,
        ctx,
        innerScope,
      );
      lines.push(`return ${fallbackExpr};`);
    } else {
      const helper = resolveVar("nonExhaustiveMatch", ctx);
      const metadataLiteral = serializeMatchMetadata(expr, ctx);
      lines.push(`${helper}(${scrutineeTemp}, ${metadataLiteral});`);
    }
    const body = lines.map((line) => indent(line)).join("\n");
    const lambda = `(${paramName}) => {\n${body}\n}`;
    const marker = resolveVar("markResultHandler", ctx);
    return `${marker}(${lambda}, [0])`;
  } else if (scrutineeIsCarrier) {
    const paramName = allocateTempName(ctx.state, "__match_value");
    const scrutineeTemp = allocateTempName(ctx.state, "__match_scrutinee");
    const baseScope = new Map(ctx.scope);
    const lines: string[] = [];
    lines.push(`const ${scrutineeTemp} = ${paramName};`);
    for (const kase of expr.cases) {
      lines.push(...emitMatchCase(kase, scrutineeTemp, ctx, baseScope));
    }
    if (expr.fallback) {
      const fallbackExpr = emitExprWithScope(
        expr.fallback,
        ctx,
        new Map(ctx.scope),
      );
      lines.push(`return ${fallbackExpr};`);
    } else {
      const helper = resolveVar("nonExhaustiveMatch", ctx);
      const metadataLiteral = serializeMatchMetadata(expr, ctx);
      lines.push(`${helper}(${scrutineeTemp}, ${metadataLiteral});`);
    }
    const body = lines.map((line) => indent(line)).join("\n");
    const lambda = `(${paramName}) => {\n${body}\n}`;
    if (patternsHandleCarrier) {
      const marker = resolveVar("markResultHandler", ctx);
      return `${marker}(${lambda}, [0])`;
    }
    return lambda;
  } else {
    const scrutineeCode = emitExpr(expr.scrutinee, ctx);
    const scrutineeTemp = allocateTempName(ctx.state, "__match_scrutinee");
    const baseScope = new Map(ctx.scope);
    const lines: string[] = [];
    lines.push(`const ${scrutineeTemp} = ${scrutineeCode};`);
    for (const kase of expr.cases) {
      lines.push(...emitMatchCase(kase, scrutineeTemp, ctx, baseScope));
    }
    if (expr.fallback) {
      const fallbackExpr = emitExprWithScope(
        expr.fallback,
        ctx,
        new Map(ctx.scope),
      );
      lines.push(`return ${fallbackExpr};`);
    } else {
      const helper = resolveVar("nonExhaustiveMatch", ctx);
      const metadataLiteral = serializeMatchMetadata(expr, ctx);
      lines.push(`${helper}(${scrutineeTemp}, ${metadataLiteral});`);
    }
    const body = lines.map((line) => indent(line)).join("\n");
    return `(() => {\n${body}\n})()`;
  }
}

function serializeMatchMetadata(
  expr: CoreExpr & { kind: "match" },
  ctx: EmitContext,
): string {
  const metadata = {
    nodeId: expr.origin ?? null,
    span: expr.span ?? null,
    patterns: expr.cases.map((kase) => describePattern(kase.pattern)),
    modulePath: ctx.modulePath ?? null,
  };
  return JSON.stringify(metadata);
}

function serializeNodeMetadata(
  node: { origin?: number; span?: unknown },
  ctx: EmitContext,
): string {
  const metadata = {
    nodeId: node.origin ?? null,
    span: node.span ?? null,
    modulePath: ctx.modulePath ?? null,
  };
  return JSON.stringify(metadata);
}

function describePattern(pattern: CorePattern): string {
  switch (pattern.kind) {
    case "wildcard":
      return "_";
    case "binding":
      return pattern.name;
    case "literal":
      return describeLiteral(pattern.literal);
    case "tuple":
      return `(${pattern.elements.map(describePattern).join(", ")})`;
    case "constructor": {
      const renderedFields = pattern.fields.map(describePattern).join(", ");
      if (!renderedFields) {
        return pattern.constructor;
      }
      return `${pattern.constructor}(${renderedFields})`;
    }
    case "all_errors":
      return "<all_errors>";
    default:
      return pattern.kind;
  }
}

function describeLiteral(literal: CoreLiteral): string {
  switch (literal.kind) {
    case "unit":
      return "()";
    case "int":
      return literal.value.toString();
    case "bool":
      return literal.value ? "true" : "false";
    case "char": {
      const char = String.fromCharCode(literal.value);
      const escaped = char === "'" ? "\\'" : char === "\\" ? "\\\\" : char;
      return `'${escaped}'`;
    }
    case "string":
      return JSON.stringify(literal.value);
    default:
      return literal.kind;
  }
}

function emitMatchCase(
  kase: CoreMatchCase,
  scrutineeRef: string,
  ctx: EmitContext,
  baseScope: Map<string, string>,
): string[] {
  const caseScope = new Map(baseScope);
  const { conditions, bindings } = emitPattern(
    kase.pattern,
    scrutineeRef,
    ctx,
    caseScope,
  );
  const conditionExpr = conditions.length > 0
    ? conditions.map((cond) => `(${cond})`).join(" && ")
    : "true";
  const guardExpr = kase.guard
    ? emitExprWithScope(kase.guard, ctx, caseScope)
    : undefined;
  const bodyExpr = emitExprWithScope(kase.body, ctx, caseScope);

  const lines: string[] = [];
  lines.push(`if (${conditionExpr}) {`);

  const innerLines: string[] = [];
  innerLines.push(...bindings);
  if (guardExpr) {
    innerLines.push(`if (${guardExpr}) {`);
    innerLines.push(indent(`return ${bodyExpr};`));
    innerLines.push(`}`);
  } else {
    innerLines.push(`return ${bodyExpr};`);
  }

  lines.push(...innerLines.map((line) => indent(line)));
  lines.push(`}`);
  return lines;
}

interface PatternEmission {
  conditions: string[];
  bindings: string[];
}

function emitPattern(
  pattern: CorePattern,
  valueRef: string,
  ctx: EmitContext,
  scope: Map<string, string>,
): PatternEmission {
  const ref = `(${valueRef})`;
  switch (pattern.kind) {
    case "wildcard":
      return { conditions: [], bindings: [] };
    case "binding": {
      const name = resolveName(scope, pattern.name, ctx.state);
      return {
        conditions: [],
        bindings: [`const ${name} = ${ref};`],
      };
    }
    case "pinned": {
      const name = resolveName(scope, pattern.name, ctx.state);
      return {
        conditions: [`${ref} === ${name}`],
        bindings: [],
      };
    }
    case "literal": {
      const literalExpr = emitLiteral({ literal: pattern.literal }, ctx);
      return {
        conditions: [`${ref} === ${literalExpr}`],
        bindings: [],
      };
    }
    case "tuple": {
      const length = pattern.elements.length;
      const conditions = [
        `Array.isArray(${ref})`,
        `${ref}.length === ${length}`,
      ];
      const bindings: string[] = [];
      for (let index = 0; index < length; index += 1) {
        const nested = emitPattern(
          pattern.elements[index],
          `${ref}[${index}]`,
          ctx,
          scope,
        );
        conditions.push(...nested.conditions);
        bindings.push(...nested.bindings);
      }
      return { conditions, bindings };
    }
    case "constructor": {
      const conditions = [
        `${ref}?.tag === "${pattern.constructor}"`,
        `${ref}?.type === "${pattern.typeName}"`,
      ];
      const bindings: string[] = [];
      for (let index = 0; index < pattern.fields.length; index += 1) {
        const nested = emitPattern(
          pattern.fields[index],
          `${ref}._${index}`,
          ctx,
          scope,
        );
        conditions.push(...nested.conditions);
        bindings.push(...nested.bindings);
      }
      return { conditions, bindings };
    }
    case "all_errors": {
      return {
        conditions: [
          `${ref}?.tag === "Err"`,
          `${ref}?.type === "${pattern.resultTypeName}"`,
        ],
        bindings: [],
      };
    }
    default: {
      const _exhaustive: never = pattern;
      void _exhaustive;
      throw new CoreLoweringError(
        `Unsupported pattern kind '${(pattern as CorePattern).kind}'`,
        (pattern as any).origin,
      );
    }
  }
}

function emitExprWithScope(
  expr: CoreExpr,
  ctx: EmitContext,
  scope: Map<string, string>,
): string {
  const previous = ctx.scope;
  ctx.scope = scope;
  try {
    return emitExpr(expr, ctx);
  } finally {
    ctx.scope = previous;
  }
}

function emitPrim(op: CorePrimOp, args: CoreExpr[], ctx: EmitContext): string {
  const emitArg = (index: number) => emitExpr(args[index], ctx);

  // Check if any argument has an infectious type
  const hasInfectiousArg = args.some((arg) => isCarrierType(arg.type));

  switch (op) {
    case "int_add":
      return `(${emitArg(0)} + ${emitArg(1)})`;
    case "int_sub":
      return `(${emitArg(0)} - ${emitArg(1)})`;
    case "int_mul":
      return `(${emitArg(0)} * ${emitArg(1)})`;
    case "int_div":
      return `Math.trunc(${emitArg(0)} / ${emitArg(1)})`;
    case "int_eq":
      if (hasInfectiousArg) {
        const eq = resolveVar("eq", ctx);
        const callInf = resolveVar("callInfectious", ctx);
        return `${callInf}(${eq}, ${emitArg(0)}, ${emitArg(1)})`;
      }
      return `(${emitArg(0)} === ${emitArg(1)})`;
    case "int_ne":
      if (hasInfectiousArg) {
        const neq = resolveVar("neq", ctx);
        const callInf = resolveVar("callInfectious", ctx);
        return `${callInf}(${neq}, ${emitArg(0)}, ${emitArg(1)})`;
      }
      return `(${emitArg(0)} !== ${emitArg(1)})`;
    case "int_lt":
      if (hasInfectiousArg) {
        const lt = resolveVar("lt", ctx);
        const callInf = resolveVar("callInfectious", ctx);
        return `${callInf}(${lt}, ${emitArg(0)}, ${emitArg(1)})`;
      }
      return `(${emitArg(0)} < ${emitArg(1)})`;
    case "int_le":
      if (hasInfectiousArg) {
        const lte = resolveVar("lte", ctx);
        const callInf = resolveVar("callInfectious", ctx);
        return `${callInf}(${lte}, ${emitArg(0)}, ${emitArg(1)})`;
      }
      return `(${emitArg(0)} <= ${emitArg(1)})`;
    case "int_gt":
      if (hasInfectiousArg) {
        const gt = resolveVar("gt", ctx);
        const callInf = resolveVar("callInfectious", ctx);
        return `${callInf}(${gt}, ${emitArg(0)}, ${emitArg(1)})`;
      }
      return `(${emitArg(0)} > ${emitArg(1)})`;
    case "int_ge":
      if (hasInfectiousArg) {
        const gte = resolveVar("gte", ctx);
        const callInf = resolveVar("callInfectious", ctx);
        return `${callInf}(${gte}, ${emitArg(0)}, ${emitArg(1)})`;
      }
      return `(${emitArg(0)} >= ${emitArg(1)})`;
    case "int_cmp": {
      const cmp = resolveVar("nativeCmpInt", ctx);
      if (hasInfectiousArg) {
        const callInf = resolveVar("callInfectious", ctx);
        return `${callInf}(${cmp}, ${emitArg(0)}, ${emitArg(1)})`;
      }
      return `${cmp}(${emitArg(0)}, ${emitArg(1)})`;
    }
    case "bool_and":
      return `(${emitArg(0)} && ${emitArg(1)})`;
    case "bool_or":
      return `(${emitArg(0)} || ${emitArg(1)})`;
    case "bool_not":
      return `(!${emitArg(0)})`;
    case "char_eq":
      if (hasInfectiousArg) {
        const charEq = resolveVar("charEq", ctx);
        const callInf = resolveVar("callInfectious", ctx);
        return `${callInf}(${charEq}, ${emitArg(0)}, ${emitArg(1)})`;
      }
      return `(${emitArg(0)} === ${emitArg(1)})`;
    case "string_length":
      return `${emitArg(0)}.length`;
    case "string_slice":
      return `${emitArg(0)}.slice(${emitArg(1)}, ${emitArg(2)})`;
    case "native_print": {
      const fn = resolveVar("nativePrint", ctx);
      return `${fn}(${emitArg(0)})`;
    }
    case "record_get": {
      const target = emitArg(0);
      const field = args[1];
      if (field.kind !== "literal" || field.literal.kind !== "string") {
        throw new Error("record_get expects string literal field");
      }
      const fieldName = JSON.stringify(field.literal.value);
      // Only use infectious accessor if target is actually infectious
      if (isCarrierType(args[0].type)) {
        const fn = resolveVar("recordGetInfectious", ctx);
        return `${fn}(${target}, ${fieldName})`;
      }
      // Regular property access for non-infectious types
      return `(${target})[${fieldName}]`;
    }
    default:
      throw new CoreLoweringError(
        `Unsupported primitive op '${op}'`,
        undefined,
      );
  }
}

function resolveVar(name: string, ctx: EmitContext): string {
  const operatorAlias = PRELUDE_OPERATOR_ALIASES.get(name) ??
    PRELUDE_PREFIX_ALIASES.get(name);
  if (operatorAlias && ctx.scope.has(operatorAlias)) {
    const resolved = ctx.scope.get(operatorAlias)!;
    ctx.scope.set(name, resolved);
    return resolved;
  }
  if (ctx.scope.has(name)) {
    return ctx.scope.get(name)!;
  }
  if (!ctx.runtimeDeps.has(name)) {
    ctx.runtimeDeps.set(name, sanitizeIdentifier(name, ctx.state));
  }
  const alias = ctx.runtimeDeps.get(name)!;
  ctx.scope.set(name, alias);
  return alias;
}

function resolveName(
  scope: Map<string, string>,
  original: string,
  state: NameState,
): string {
  if (scope.has(original)) {
    return scope.get(original)!;
  }
  const sanitized = sanitizeIdentifier(original, state);
  scope.set(original, sanitized);
  return sanitized;
}

const RESERVED = new Set<string>([
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "export",
  "extends",
  "finally",
  "for",
  "function",
  "if",
  "import",
  "in",
  "instanceof",
  "new",
  "return",
  "super",
  "switch",
  "this",
  "throw",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield",
  "enum",
  "await",
  "implements",
  "package",
  "protected",
  "static",
  "interface",
  "private",
  "public",
]);

function sanitizeIdentifier(name: string, state: NameState): string {
  const base = makeIdentifierBase(name);
  let candidate = base;
  while (RESERVED.has(candidate) || state.used.has(candidate)) {
    candidate = `${base}_${state.counter++}`;
  }
  state.used.add(candidate);
  return candidate;
}

function allocateTempName(state: NameState, base: string): string {
  return sanitizeIdentifier(base, state);
}

function makeIdentifierBase(name: string): string {
  const cleaned = name.replace(/[^A-Za-z0-9_$]/g, "_");
  if (/^[A-Za-z_$]/.test(cleaned)) {
    return cleaned;
  }
  return `_${cleaned || "name"}`;
}

function indent(text: string): string {
  return text.split("\n").map((line) => (line.length > 0 ? `  ${line}` : line))
    .join("\n");
}

export class CoreLoweringError extends Error {
  constructor(message: string, public readonly nodeId?: number) {
    super(message);
    // Don't set this.name - causes issues in Nova
    // this.name = "CoreLoweringError";
  }
}
