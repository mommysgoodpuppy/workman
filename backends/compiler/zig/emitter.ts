import { dirname, extname, join, relative } from "../../../src/io.ts";
import type { SourceSpan } from "../../../src/ast.ts";
import type { TraceOptions } from "../../../src/trace_options.ts";
import type {
  CoreExpr,
  CoreLiteral,
  CoreMatchCase,
  CoreModule,
  CoreModuleGraph,
  CorePattern,
  CorePrimOp,
  CoreTypeConstructor,
  CoreTypeDeclaration,
} from "../ir/core.ts";

interface NameState {
  used: Set<string>;
  counter: number;
}

interface VarRef {
  value: string;
  address: string;
}

interface EmitContext {
  state: NameState;
  scope: Map<string, VarRef>;
  options: EmitModuleOptions;
  modulePath: string;
  hoisted: string[];
}

export interface EmitModuleOptions {
  readonly extension?: string;
  readonly runtimeModule?: string;
  readonly baseDir?: string; // directory of the emitted module file
  readonly forcedValueExports?: readonly string[];
  readonly preludeModule?: {
    specifier: string;
    names: readonly string[];
  };
  readonly invokeEntrypoint?: boolean;
  readonly getSourceLocation?: (
    span: SourceSpan,
  ) =>
    | { line: number; column: number; file: string; lineText?: string }
    | undefined;
  readonly traceOptions?: TraceOptions;
}

const RESERVED = new Set<string>([
  "align",
  "allowzero",
  "and",
  "anyframe",
  "anytype",
  "asm",
  "async",
  "await",
  "break",
  "catch",
  "comptime",
  "const",
  "continue",
  "defer",
  "else",
  "enum",
  "errdefer",
  "error",
  "export",
  "extern",
  "false",
  "for",
  "if",
  "inline",
  "linksection",
  "noalias",
  "noinline",
  "nosuspend",
  "opaque",
  "or",
  "orelse",
  "packed",
  "pub",
  "resume",
  "return",
  "struct",
  "suspend",
  "switch",
  "test",
  "threadlocal",
  "true",
  "try",
  "union",
  "unreachable",
  "usingnamespace",
  "var",
  "volatile",
  "while",
  "_",
  "__wm_init",
  "__wm_init_state",
]);

const INIT_FN = "__wm_init";
const INIT_STATE = "__wm_init_state";

const PRELUDE_OPERATOR_ALIASES = new Map<string, string>([
  ["__op_+", "add"],
  ["__op_-", "sub"],
  ["__op_*", "mul"],
  ["__op_/", "div"],
  ["__op_==", "eq"],
  ["__op_!=", "neq"],
  ["__op_<", "lt"],
  ["__op_>", "gt"],
  ["__op_<=", "lte"],
  ["__op_>=", "gte"],
  ["__op_&&", "boolAnd"],
  ["__op_||", "boolOr"],
  ["__op_++", "stringConcat"],
]);

const PRELUDE_PREFIX_ALIASES = new Map<string, string>([
  ["__prefix_!", "not"],
]);

export function emitModule(
  module: CoreModule,
  graph: CoreModuleGraph,
  options: EmitModuleOptions = {},
): string {
  const extension = options.extension ?? ".zig";
  const runtimeModule = options.runtimeModule ?? "./runtime.zig";

  const state: NameState = { used: new Set(), counter: 0 };
  const scope = new Map<string, VarRef>();
  const ctx: EmitContext = {
    state,
    scope,
    options: { ...options, extension, runtimeModule },
    modulePath: module.path,
    hoisted: [],
  };
  //console.log(`emitModule: baseDir=${options.baseDir}`);

  preallocateNames(module, coreGraphImports(module), ctx);

  const lines: string[] = [];
  lines.push("// Generated by Workman compiler (Zig)");
  lines.push(`pub const runtime = @import("${runtimeModule}");`);
  lines.push(`const Value = runtime.Value;`);
  const traceConfigLiteral = options.traceOptions
    ? formatTraceOptionsLiteral(options.traceOptions)
    : undefined;
  if (traceConfigLiteral) {
    lines.push(`const __wm_trace_options = ${traceConfigLiteral};`);
  }

  const exportSet = buildExportSet(module);
  const forcedValueExports = new Set(options.forcedValueExports ?? []);
  const initLines: string[] = [];
  const importLines = emitImports(module, ctx, exportSet, initLines, graph);
  if (importLines.length > 0) {
    lines.push(...importLines);
  }

  const preludeLines = emitPreludeImports(
    ctx,
    options.preludeModule,
    initLines,
  );
  if (preludeLines.length > 0) {
    lines.push(...preludeLines);
  }

  lines.push(`var ${INIT_STATE}: u8 = 0;`);

  const typeLines = emitTypeDeclarations(
    module.typeDeclarations,
    ctx,
    initLines,
  );
  const valueLines: string[] = [];
  for (const binding of module.values) {
    const bindingRef = resolveName(ctx.scope, binding.name, ctx.state);
    const expr = emitExpr(binding.value, ctx, binding.name);
    const isExported = exportSet.has(binding.name) ||
      forcedValueExports.has(binding.name);
    valueLines.push(
      `${isExported ? "pub " : ""}var ${bindingRef}: Value = undefined;`,
    );
    if (ctx.options.getSourceLocation && binding.value.span) {
      const loc = ctx.options.getSourceLocation(binding.value.span);
      if (loc) {
        initLines.push(formatWmComment(loc));
      }
    }
    initLines.push(`${bindingRef} = ${expr};`);
  }
  const exportLines = emitExports(module, ctx, exportSet, initLines);
  const mainLines: string[] = [];
  const hasMain = module.values.some((binding) => binding.name === "main");
  if (
    module.path === graph.entry &&
    (options.invokeEntrypoint ?? true) &&
    hasMain
  ) {
    const mainRef = resolveVar("main", ctx).value;
    mainLines.push("");
    mainLines.push("pub fn main() void {");
    mainLines.push(indent(`${INIT_FN}();`));
    mainLines.push(indent(`_ = runtime.call(${mainRef}, &[_]Value{}, "");`));
    mainLines.push("}");
  }

  if (ctx.hoisted.length > 0) {
    lines.push(...ctx.hoisted);
  }
  if (typeLines.length > 0) {
    lines.push(...typeLines);
  }
  if (valueLines.length > 0) {
    lines.push(...valueLines);
  }
  if (exportLines.length > 0) {
    lines.push(...exportLines);
  }
  lines.push("");
  lines.push(`pub fn ${INIT_FN}() void {`);
  if (traceConfigLiteral) {
    lines.push(indent(`runtime.configureTrace(__wm_trace_options);`));
  }
  lines.push(indent(`if (${INIT_STATE} == 2) return;`));
  lines.push(indent(`if (${INIT_STATE} == 1) return;`));
  lines.push(indent(`${INIT_STATE} = 1;`));
  if (initLines.length > 0) {
    for (const initLine of initLines) {
      lines.push(indent(initLine));
    }
  }
  lines.push(indent(`${INIT_STATE} = 2;`));
  lines.push("}");
  if (mainLines.length > 0) {
    lines.push(...mainLines);
  }

  return `${lines.join("\n")}\n`;
}

function formatTraceOptionsLiteral(options: TraceOptions): string {
  const printValue = options.print ? "true" : "false";
  const captureValue = options.capture ? "true" : "false";
  return `runtime.TraceOptions{ .print = ${printValue}, .capture = ${captureValue} }`;
}

function buildExportSet(module: CoreModule): Set<string> {
  const exported = new Set<string>();
  const validValues = new Set<string>();

  for (const value of module.values) {
    validValues.add(value.name);
    if (value.exported) exported.add(value.name);
  }
  for (const decl of module.typeDeclarations) {
    for (const ctor of decl.constructors) {
      validValues.add(ctor.name);
      if (ctor.exported) exported.add(ctor.name);
    }
  }
  // Also add imports to validValues so re-exports work
  for (const entry of module.imports) {
    for (const spec of entry.specifiers) {
      validValues.add(spec.local);
    }
  }

  for (const exp of module.exports) {
    if (exp.kind === "value") {
      if (validValues.has(exp.local)) {
        exported.add(exp.local);
      }
    } else if (exp.kind === "constructor") {
      if (validValues.has(exp.ctor)) {
        exported.add(exp.ctor);
      }
    }
  }
  return exported;
}

function coreGraphImports(module: CoreModule): string[] {
  const names: string[] = [];
  for (const record of module.imports) {
    for (const spec of record.specifiers) {
      names.push(spec.local);
    }
  }
  return names;
}

function preallocateNames(
  module: CoreModule,
  importNames: string[],
  ctx: EmitContext,
): void {
  for (const name of importNames) {
    bindLocal(ctx.scope, name, ctx.state);
  }
  for (const decl of module.typeDeclarations) {
    for (const ctor of decl.constructors) {
      bindLocal(ctx.scope, ctor.name, ctx.state);
    }
  }
  for (const binding of module.values) {
    bindLocal(ctx.scope, binding.name, ctx.state);
  }
}

function emitImports(
  module: CoreModule,
  ctx: EmitContext,
  exportSet: Set<string>,
  initLines: string[],
  graph: CoreModuleGraph,
): string[] {
  if (module.imports.length === 0) return [];

  const currentDir = ctx.options.baseDir ?? dirname(module.path);
  const lines: string[] = [];
  let importCounter = 0;
  for (const entry of module.imports) {
    const importedModule = findModuleInGraph(graph, entry.source);
    let importedValues: Set<string> | undefined;

    if (importedModule) {
      importedValues = buildExportSet(importedModule);
    }

    const alias = allocateTempName(ctx.state, `__mod_${importCounter++}`);
    const importPath = makeImportPath(
      currentDir,
      entry.source,
      ctx.options.extension ?? ".zig",
    );
    lines.push(`const ${alias} = @import("${importPath}");`);

    const isNative = (entry as any).isNative === true ||
      ((entry as any).isNative === undefined && entry.source.endsWith(".zig"));

    if (!isNative) {
      initLines.push(`${alias}.${INIT_FN}();`);
    }
    for (const spec of entry.specifiers) {
      if (importedValues && !importedValues.has(spec.imported)) {
        continue;
      }
      const local = resolveName(ctx.scope, spec.local, ctx.state);
      const exported = exportSet.has(spec.local) ? "pub " : "";
      lines.push(`${exported}var ${local}: Value = undefined;`);
      const fieldName = spec.imported.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
      initLines.push(`${local} = @field(${alias}, "${fieldName}");`);
    }
  }

  return lines;
}

function emitPreludeImports(
  ctx: EmitContext,
  prelude?: { specifier: string; names: readonly string[] },
  initLines: string[] = [],
  ): string[] {
    if (!prelude) return [];
    const lines: string[] = [];
    const alias = allocateTempName(ctx.state, "__prelude");
    lines.push(`const ${alias} = @import("${prelude.specifier}");`);
    initLines.push(`${alias}.${INIT_FN}();`);
    for (const name of prelude.names) {
      if (ctx.scope.has(name)) continue;
      const local = resolveName(ctx.scope, name, ctx.state);
      lines.push(`var ${local}: Value = undefined;`);
      const fieldName = name.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
      initLines.push(`${local} = @field(${alias}, "${fieldName}");`);
    }
    return lines;
  }

function makeImportPath(
  fromDir: string,
  target: string,
  extension: string,
): string {
  //console.log(`makeImportPath: fromDir=${fromDir}, target=${target}`);
  let rel = relative(fromDir, target);
  if (rel === "") rel = ".";
  if (!rel.startsWith(".")) {
    rel = `./${rel}`;
  }
  rel = rel.replace(/\\/g, "/");
  const existingExt = extname(rel);
  if (existingExt === "") {
    rel = `${rel}${extension}`;
  } else if (existingExt === ".wm") {
    rel = `${rel.slice(0, rel.length - existingExt.length)}${extension}`;
  }
  return rel;
}

function emitTypeDeclarations(
  declarations: readonly CoreTypeDeclaration[],
  ctx: EmitContext,
  initLines: string[],
): string[] {
  const lines: string[] = [];
  for (const decl of declarations) {
    for (const ctor of decl.constructors) {
      lines.push(...emitConstructor(decl, ctor, ctx, initLines));
    }
    if (
      decl.infectious && decl.infectious.valueConstructor &&
      decl.infectious.effectConstructors
    ) {
      const effectCtors = decl.infectious.effectConstructors
        .map((ctor) => `"${ctor}"`)
        .join(", ");
      initLines.push(
        `runtime.registerInfectiousType("${decl.name}", "${decl.infectious.valueConstructor}", &[_][]const u8{ ${effectCtors} });`,
      );
    }
  }
  return lines;
}

function emitConstructor(
  decl: CoreTypeDeclaration,
  ctor: CoreTypeConstructor,
  ctx: EmitContext,
  initLines: string[],
): string[] {
  const name = resolveName(ctx.scope, ctor.name, ctx.state);
  if (ctor.arity === 0) {
    initLines.push(
      `${name} = runtime.makeData("${decl.name}", "${ctor.name}", &[_]Value{});`,
    );
    return [
      `${ctor.exported ? "pub " : ""}var ${name}: Value = undefined;`,
    ];
  }

  const fnName = allocateTempName(ctx.state, `__ctor_${ctor.name}`);
  const params = Array.from({ length: ctor.arity }, (_, i) => `__args[${i}]`);
  const fields = params.join(", ");
  const body =
    `return runtime.makeData("${decl.name}", "${ctor.name}", &[_]Value{ ${fields} });`;

  ctx.hoisted.push(
    `fn ${fnName}(env_ptr: ?*anyopaque, __args: []const Value) Value {`,
  );
  ctx.hoisted.push(indent("_ = env_ptr;"));
  ctx.hoisted.push(indent(body));
  ctx.hoisted.push("}");

  initLines.push(
    `${name} = runtime.makeFunc(${fnName}, null, "${ctor.name}");`,
  );
  return [
    `${ctor.exported ? "pub " : ""}var ${name}: Value = undefined;`,
  ];
}

function emitExports(
  module: CoreModule,
  ctx: EmitContext,
  exportSet: Set<string>,
  initLines: string[],
): string[] {
  const lines: string[] = [];
  const exportedNames = new Set<string>();
  for (const exp of module.exports) {
    if (exp.kind === "type") continue;

    // Determine the local name we are trying to export
    let localOriginal: string;
    if (exp.kind === "value") {
      localOriginal = exp.local;
    } else {
      // For constructors, try to find the constructor name in scope.
      // If not in scope, fall back to the exported name (which might be the constructor name).
      if (ctx.scope.has(exp.ctor)) {
        localOriginal = exp.ctor;
      } else {
        localOriginal = exp.exported;
      }
    }

    // Verify if localOriginal is actually in scope.
    // If not, resolveName will create a NEW binding (e.g. __0), but since we didn't emit a var for it,
    // using it will cause a Zig error "use of undeclared identifier".
    if (!ctx.scope.has(localOriginal)) {
      continue;
    }

    const localName = resolveName(ctx.scope, localOriginal, ctx.state);
    const exported = sanitizeExportName(exp.exported, localName, ctx.state);

    // Identify attempts to export as "_" which causes valid Zig "_ = val" assignment but invalid "pub var _"
    if (exported === "_") {
      continue;
    }

    if (exported === localName) {
      continue;
    }
    if (exportedNames.has(exported)) continue;
    lines.push(`pub var ${exported}: Value = undefined;`);
    initLines.push(`${exported} = ${localName};`);
    exportedNames.add(exported);
  }
  return lines;
}

function emitExpr(expr: CoreExpr, ctx: EmitContext, nameHint?: string): string {
  return emitExprInner(expr, ctx, nameHint);
}

function emitExprWithComment(expr: CoreExpr, ctx: EmitContext, nameHint?: string): string {
  const result = emitExprInner(expr, ctx, nameHint);
  if (ctx.options.getSourceLocation && expr.span) {
    const loc = ctx.options.getSourceLocation(expr.span);
    if (loc) {
      return `
${formatWmComment(loc)}
${result}`;
    }
  }
  return result;
}

function emitExprInner(
  expr: CoreExpr,
  ctx: EmitContext,
  nameHint?: string,
): string {
  switch (expr.kind) {
    case "literal":
      return emitLiteral(expr, ctx);
    case "var":
      return resolveVar(expr.name, ctx).value;
    case "tuple":
      return `runtime.makeTuple(&[_]Value{ ${
        expr.elements.map((el) => emitExpr(el, ctx)).join(", ")
      } })`;
    case "record":
      return emitRecord(expr, ctx);
    case "tuple_get":
      return `runtime.tupleGet(${emitExpr(expr.target, ctx)}, ${expr.index})`;
    case "data":
      return emitData(expr, ctx);
    case "lambda":
      return emitLambda(expr, ctx, nameHint);
    case "call":
      return emitCall(expr, ctx);
    case "let":
      return emitLet(expr, ctx);
    case "let_rec":
      return emitLetRec(expr, ctx);
    case "prim":
      return emitPrim(expr.op, expr.args, ctx);
    case "if":
      return `if (runtime.expectBool(${emitExpr(expr.condition, ctx)})) ${
        emitExpr(expr.thenBranch, ctx)
      } else ${emitExpr(expr.elseBranch, ctx)}`;
    case "match":
      return emitMatch(expr, ctx);
    case "carrier_unwrap":
      return `runtime.carrierUnwrap(${emitExpr(expr.target, ctx)}, "${expr.carrierType}")`;
    case "carrier_wrap":
      return `runtime.carrierWrap(${emitExpr(expr.target, ctx)}, "${expr.carrierType}")`;
    case "carrier_match": {
      const scrutineeCode = emitExpr(expr.scrutinee, ctx);
      const matchExpr: CoreExpr & { kind: "match" } = {
        kind: "match",
        type: expr.type,
        scrutinee: expr.scrutinee,
        cases: expr.cases,
        fallback: expr.fallback,
        effectRowCoverage: undefined,
        origin: expr.origin,
        span: expr.span,
      };
      const matchLambda = emitMatchLambda(matchExpr, ctx);

      let callSite = '""';
      if (ctx.options.getSourceLocation && expr.span) {
        const loc = ctx.options.getSourceLocation(expr.span);
        if (loc) {
          const escapedFile = loc.file.replace(/\\/g, "/");
          let siteStr = `${escapedFile}:${loc.line}:${loc.column}`;
          if (loc.lineText) {
            const escapedLine = loc.lineText
              .replace(/\\/g, "\\\\")
              .replace(/"/g, '\\"')
              .replace(/\n/g, "\\n")
              .replace(/\r/g, "\\r")
              .replace(/\t/g, "    ");

            const indent = " ".repeat(Math.max(0, loc.column - 1));
            siteStr += `\\n    ${escapedLine}\\n    ${indent}^`;
          }
          callSite = `"${siteStr}"`;
        }
      }

      return `runtime.carrierMatch(${matchLambda}, ${scrutineeCode}, "${expr.carrierType}", ${callSite})`;
    }
    case "coerce":
      return emitExpr(expr.expr, ctx);
    default:
      throw new Error(
        `Unsupported expression kind '${(expr as CoreExpr).kind}'`,
      );
  }
}

function formatWmComment(loc: {
  file: string;
  line: number;
  column: number;
  lineText?: string;
}): string {
  const escapedFile = loc.file.replace(/\\/g, "/");
  let comment = `// wm: ${escapedFile}:${loc.line}:${loc.column}`;
  if (loc.lineText) {
    const escapedLine = loc.lineText.replace(/\\/g, "\\\\").replace(/\r/g, "");
    comment += ` | ${escapedLine}`;
  }
  return comment;
}

function emitLiteral(
  expr: { literal: { kind: string; value?: unknown } },
  _ctx: EmitContext,
): string {
  switch (expr.literal.kind) {
    case "unit":
      return "runtime.makeUnit()";
    case "int":
    case "char":
      return `runtime.makeInt(${String(expr.literal.value)})`;
    case "bool":
      return expr.literal.value
        ? "runtime.makeBool(true)"
        : "runtime.makeBool(false)";
    case "string":
      return `runtime.makeString(${JSON.stringify(expr.literal.value)})`;
    default:
      throw new Error(`Unsupported literal kind '${expr.literal.kind}'`);
  }
}

function emitRecord(
  expr: CoreExpr & { kind: "record" },
  ctx: EmitContext,
): string {
  if (expr.fields.length === 0) {
    return "runtime.makeRecord(&[_]runtime.RecordField{})";
  }
  const fields = expr.fields.map((field) => {
    const value = emitExpr(field.value, ctx);
    return `.{ .name = ${JSON.stringify(field.name)}, .value = ${value} }`;
  }).join(", ");
  return `runtime.makeRecord(&[_]runtime.RecordField{ ${fields} })`;
}

function emitData(expr: CoreExpr & { kind: "data" }, ctx: EmitContext): string {
  const fields = expr.fields.map((field) => emitExpr(field, ctx)).join(", ");
  return `runtime.makeData("${expr.typeName}", "${expr.constructor}", &[_]Value{ ${fields} })`;
}

function emitLambda(
  expr: CoreExpr & { kind: "lambda" },
  ctx: EmitContext,
  nameHint?: string,
): string {
  const usedVars = collectUsedVars(expr.body);
  const { freeVars } = collectFreeVars(expr.body, new Set(expr.params));
  const captures = Array.from(freeVars).filter((name) => ctx.scope.has(name));
  const lambdaName = allocateTempName(
    ctx.state,
    nameHint ? sanitizeIdentifier(nameHint, ctx.state) : "__lambda",
  );

  let envType: string | undefined;
  let envInit = "null";
  const scope = new Map(ctx.scope);

  if (captures.length > 0) {
    envType = allocateTempName(ctx.state, "__env");
    const fieldNames = new Map<string, string>();
    const fields = captures.map((name) => {
      const fieldName = sanitizeIdentifier(name, ctx.state);
      const ref = resolveVar(name, ctx);
      const captureByRef = !ref.address.startsWith("&");
      fieldNames.set(name, fieldName);
      scope.set(name, {
        value: captureByRef ? `env.${fieldName}.*` : `env.${fieldName}`,
        address: captureByRef ? `env.${fieldName}` : `&env.${fieldName}`,
      });
      return `${fieldName}: ${captureByRef ? "*Value" : "Value"}`;
    });
    ctx.hoisted.push(`const ${envType} = struct { ${fields.join(", ")} };`);
    const initFields = captures.map((name) => {
      const ref = resolveVar(name, ctx);
      const fieldName = fieldNames.get(name)!;
      const captureByRef = !ref.address.startsWith("&");
      return `.${fieldName} = ${captureByRef ? ref.address : ref.value}`;
    }).join(", ");
    envInit = `runtime.allocEnv(${envType}, .{ ${initFields} })`;
  }

  const params = expr.params.flatMap((param, index) => {
    if (!usedVars.has(param)) return [];
    const local = bindShadowingLocal(scope, param, ctx.state);
    return [{ name: local, index }];
  });
  const body = emitExprWithScope(expr.body, ctx, scope);

  ctx.hoisted.push(
    `fn ${lambdaName}(env_ptr: ?*anyopaque, __args: []const Value) Value {`,
  );
  if (captures.length > 0) {
    ctx.hoisted.push(
      indent(`const env: *${envType} = @ptrCast(@alignCast(env_ptr.?));`),
    );
  } else {
    ctx.hoisted.push(indent("_ = env_ptr;"));
  }
  if (params.length === 0) {
    ctx.hoisted.push(indent("_ = __args;"));
  }
  for (const param of params) {
    ctx.hoisted.push(
      indent(`const ${param.name} = __args[${param.index}];`),
    );
  }
  ctx.hoisted.push(indent(`return ${body};`));
  ctx.hoisted.push("}");

  let debugName = lambdaName;
  const span = expr.span ?? expr.body.span;
  if (ctx.options.getSourceLocation && span) {
    const loc = ctx.options.getSourceLocation(span);
    if (loc) {
      debugName = `${lambdaName} (${loc.file}:${loc.line}:${loc.column})`;
      {
        const parts = loc.file.replace(/\\/g, "/").split("/");
        const fileName = parts[parts.length - 1];
        debugName = `${lambdaName} (${fileName}:${loc.line})`;
      }
    }
  }

  return `runtime.makeFunc(${lambdaName}, ${envInit}, "${debugName}")`;
}

function collectFreeVars(
  expr: CoreExpr,
  bound: Set<string>,
): { freeVars: Set<string> } {
  const freeVars = new Set<string>();

  function visit(node: CoreExpr, localBound: Set<string>): void {
    switch (node.kind) {
      case "literal":
        return;
      case "var":
        if (!localBound.has(node.name)) {
          freeVars.add(node.name);
        }
        return;
      case "tuple":
        node.elements.forEach((el) => visit(el, localBound));
        return;
      case "record":
        node.fields.forEach((field) => visit(field.value, localBound));
        return;
      case "tuple_get":
        visit(node.target, localBound);
        return;
      case "data":
        node.fields.forEach((field) => visit(field, localBound));
        return;
      case "lambda": {
        const nextBound = new Set(localBound);
        node.params.forEach((p) => nextBound.add(p));
        visit(node.body, nextBound);
        return;
      }
      case "call":
        visit(node.callee, localBound);
        node.args.forEach((arg) => visit(arg, localBound));
        return;
      case "let": {
        visit(node.binding.value, localBound);
        const nextBound = new Set(localBound);
        nextBound.add(node.binding.name);
        visit(node.body, nextBound);
        return;
      }
      case "let_rec": {
        const nextBound = new Set(localBound);
        node.bindings.forEach((binding) => nextBound.add(binding.name));
        node.bindings.forEach((binding) => visit(binding.value, nextBound));
        visit(node.body, nextBound);
        return;
      }
      case "if":
        visit(node.condition, localBound);
        visit(node.thenBranch, localBound);
        visit(node.elseBranch, localBound);
        return;
      case "prim":
        node.args.forEach((arg) => visit(arg, localBound));
        return;
      case "match": {
        visit(node.scrutinee, localBound);
        for (const kase of node.cases) {
          const caseBound = new Set(localBound);
          for (const name of boundNamesInPattern(kase.pattern)) {
            caseBound.add(name);
          }
          if (kase.guard) visit(kase.guard, caseBound);
          visit(kase.body, caseBound);
        }
        if (node.fallback) visit(node.fallback, localBound);
        return;
      }
      case "carrier_unwrap":
        visit(node.target, localBound);
        return;
      case "carrier_wrap":
        visit(node.target, localBound);
        return;
      case "carrier_match": {
        visit(node.scrutinee, localBound);
        for (const kase of node.cases) {
          const caseBound = new Set(localBound);
          for (const name of boundNamesInPattern(kase.pattern)) {
            caseBound.add(name);
          }
          if (kase.guard) visit(kase.guard, caseBound);
          visit(kase.body, caseBound);
        }
        if (node.fallback) visit(node.fallback, localBound);
        return;
      }
      default:
        return;
    }
  }

  visit(expr, bound);
  return { freeVars };
}

function collectUsedVars(expr: CoreExpr): Set<string> {
  const used = new Set<string>();

  function visit(node: CoreExpr): void {
    switch (node.kind) {
      case "literal":
        return;
      case "var":
        used.add(node.name);
        return;
      case "tuple":
        node.elements.forEach(visit);
        return;
      case "record":
        node.fields.forEach((field) => visit(field.value));
        return;
      case "tuple_get":
        visit(node.target);
        return;
      case "data":
        node.fields.forEach(visit);
        return;
      case "lambda":
        visit(node.body);
        return;
      case "call":
        visit(node.callee);
        node.args.forEach(visit);
        return;
      case "let":
        visit(node.binding.value);
        visit(node.body);
        return;
      case "let_rec":
        node.bindings.forEach((binding) => visit(binding.value));
        visit(node.body);
        return;
      case "if":
        visit(node.condition);
        visit(node.thenBranch);
        visit(node.elseBranch);
        return;
      case "prim":
        node.args.forEach(visit);
        return;
      case "match":
        visit(node.scrutinee);
        node.cases.forEach((kase) => {
          collectPinnedNames(kase.pattern).forEach((name) => used.add(name));
          if (kase.guard) visit(kase.guard);
          visit(kase.body);
        });
        if (node.fallback) visit(node.fallback);
        return;
      case "carrier_unwrap":
        visit(node.target);
        return;
      case "carrier_wrap":
        visit(node.target);
        return;
      case "carrier_match":
        visit(node.scrutinee);
        node.cases.forEach((kase) => {
          collectPinnedNames(kase.pattern).forEach((name) => used.add(name));
          if (kase.guard) visit(kase.guard);
          visit(kase.body);
        });
        if (node.fallback) visit(node.fallback);
        return;
      default:
        return;
    }
  }

  visit(expr);
  return used;
}

function collectPinnedNames(pattern: CorePattern): string[] {
  switch (pattern.kind) {
    case "pinned":
      return [pattern.name];
    case "tuple":
      return pattern.elements.flatMap(collectPinnedNames);
    case "constructor":
      return pattern.fields.flatMap(collectPinnedNames);
    case "binding":
    case "wildcard":
    case "literal":
    case "all_errors":
      return [];
    default:
      return [];
  }
}

function boundNamesInPattern(pattern: CorePattern): string[] {
  switch (pattern.kind) {
    case "binding":
      return [pattern.name];
    case "tuple":
      return pattern.elements.flatMap(boundNamesInPattern);
    case "constructor":
      return pattern.fields.flatMap(boundNamesInPattern);
    case "wildcard":
    case "literal":
    case "pinned":
    case "all_errors":
      return [];
    default:
      return [];
  }
}

function emitCall(expr: CoreExpr & { kind: "call" }, ctx: EmitContext): string {
  const callee = emitExpr(expr.callee, ctx);
  const args = expr.args.map((arg) => emitExpr(arg, ctx)).join(", ");

  let callSite = '""';
  if (ctx.options.getSourceLocation && expr.span) {
    const loc = ctx.options.getSourceLocation(expr.span);
    if (loc) {
      // Escape for Zig string literal
      const escapedFile = loc.file.replace(/\\/g, "/");
      let siteStr = `${escapedFile}:${loc.line}:${loc.column}`;
      if (loc.lineText) {
        const escapedLine = loc.lineText
          .replace(/\\/g, "\\\\")
          .replace(/"/g, '\\"')
          .replace(/\n/g, "\\n")
          .replace(/\r/g, "\\r")
          .replace(/\t/g, "    "); // convert tabs to spaces for alignment

        const indent = " ".repeat(Math.max(0, loc.column - 1));
        siteStr += `\\n    ${escapedLine}\\n    ${indent}^`;
      }
      callSite = `"${siteStr}"`;
    }
  }

  return `runtime.call(${callee}, &[_]Value{ ${args} }, ${callSite})`;
}

function emitLet(expr: CoreExpr & { kind: "let" }, ctx: EmitContext): string {
  const usedVars = collectUsedVars(expr.body);
  const innerScope = new Map(ctx.scope);
  const bindingName = bindShadowingLocal(
    innerScope,
    expr.binding.name,
    ctx.state,
  );
  const valueScope = expr.binding.isRecursive ? innerScope : ctx.scope;
  const valueCode = emitExprWithScope(
    expr.binding.value,
    ctx,
    valueScope,
    expr.binding.name,
  );
  const bodyCode = emitExprWithScope(expr.body, ctx, innerScope);
  const label = allocateLabel(ctx.state);
  const isStmt = expr.binding.name.startsWith("__stmt");
  const isUsed = usedVars.has(expr.binding.name);
  const valueIsTrivial = expr.binding.value.kind === "var" ||
    expr.binding.value.kind === "literal";
  if (isStmt || (!isUsed && !expr.binding.isRecursive)) {
    const evaluateValue = !valueIsTrivial;
    const valueLine = evaluateValue ? indent(`_ = ${valueCode};`) : "";
    const bodyLine = indent(`break :${label} ${bodyCode};`);
    const lines = [valueLine, bodyLine].filter((line) => line !== "");
    return `${label}: {\n${lines.join("\n")}\n}`;
  }
  return `${label}: {\n${indent(`const ${bindingName} = ${valueCode};`)}\n${
    indent(`break :${label} ${bodyCode};`)
  }\n}`;
}

function emitLetRec(
  expr: CoreExpr & { kind: "let_rec" },
  ctx: EmitContext,
): string {
  const usedVars = collectUsedVars(expr.body);
  for (const binding of expr.bindings) {
    const bindingUsed = collectUsedVars(binding.value);
    for (const name of bindingUsed) {
      usedVars.add(name);
    }
  }
  const innerScope = new Map(ctx.scope);
  const boxNames = new Map<string, string>();
  for (const binding of expr.bindings) {
    const boxName = allocateTempName(ctx.state, `${binding.name}_box`);
    innerScope.set(binding.name, {
      value: `${boxName}.*`,
      address: boxName,
    });
    boxNames.set(binding.name, boxName);
  }
  const lines: string[] = [];
  for (const binding of expr.bindings) {
    const boxName = boxNames.get(binding.name)!;
    lines.push(`const ${boxName} = runtime.allocValue();`);
    lines.push(`${boxName}.* = runtime.makeUnit();`);
  }
  for (const binding of expr.bindings) {
    const value = emitExprWithScope(binding.value, ctx, innerScope);
    const boxName = boxNames.get(binding.name)!;
    lines.push(`${boxName}.* = ${value};`);
  }
  for (const binding of expr.bindings) {
    if (!usedVars.has(binding.name)) {
      const boxName = boxNames.get(binding.name)!;
      lines.push(`_ = ${boxName};`);
    }
  }
  const body = emitExprWithScope(expr.body, ctx, innerScope);
  const label = allocateLabel(ctx.state);
  lines.push(`break :${label} ${body};`);
  const bodyLines = lines.map(indent).join("\n");
  return `${label}: {\n${bodyLines}\n}`;
}

function emitMatch(
  expr: CoreExpr & { kind: "match" },
  ctx: EmitContext,
): string {
  const scrutineeCode = emitExpr(expr.scrutinee, ctx);
  return emitMatchWithScrutinee(expr, ctx, scrutineeCode);
}

function emitMatchWithScrutinee(
  expr: CoreExpr & { kind: "match" },
  ctx: EmitContext,
  scrutineeCode: string,
  baseScope: Map<string, VarRef> = new Map(ctx.scope),
): string {
  const scrutineeTemp = allocateTempName(ctx.state, "__match_scrutinee");
  const scrutineeTypeName = expr.scrutinee.type.kind === "constructor"
    ? expr.scrutinee.type.name
    : undefined;
  const label = allocateLabel(ctx.state);
  const lines: string[] = [];
  lines.push(`const ${scrutineeTemp} = ${scrutineeCode};`);
  for (const kase of expr.cases) {
    lines.push(
      ...emitMatchCase(
        kase,
        scrutineeTemp,
        ctx,
        baseScope,
        label,
        scrutineeTypeName,
      ),
    );
  }
  if (expr.fallback) {
    const fallbackExpr = emitExprWithScope(expr.fallback, ctx, baseScope);
    lines.push(`break :${label} ${fallbackExpr};`);
  } else {
    let locationString = '""';
    if (ctx.options.getSourceLocation && expr.span) {
      const loc = ctx.options.getSourceLocation(expr.span);
      if (loc) {
        lines.push(formatWmComment(loc));
        locationString = `"${loc.file}:${loc.line}:${loc.column}"`;
      }
    }
    lines.push(
      `break :${label} runtime.nonExhaustiveMatch(${scrutineeTemp}, ${locationString});`,
    );
  }
  const body = lines.map(indent).join("\n");
  return `${label}: {\n${body}\n}`;
}

function emitMatchLambda(
  expr: CoreExpr & { kind: "match" },
  ctx: EmitContext,
): string {
  const { freeVars } = collectFreeVarsInMatchBody(expr, new Set());
  const captures = Array.from(freeVars).filter((name) => ctx.scope.has(name));
  const lambdaName = allocateTempName(ctx.state, "__match_lambda");

  let envType: string | undefined;
  let envInit = "null";
  const scope = new Map(ctx.scope);

  if (captures.length > 0) {
    envType = allocateTempName(ctx.state, "__env");
    const fieldNames = new Map<string, string>();
    const fields = captures.map((name) => {
      const fieldName = sanitizeIdentifier(name, ctx.state);
      const ref = resolveVar(name, ctx);
      const captureByRef = !ref.address.startsWith("&");
      fieldNames.set(name, fieldName);
      scope.set(name, {
        value: captureByRef ? `env.${fieldName}.*` : `env.${fieldName}`,
        address: captureByRef ? `env.${fieldName}` : `&env.${fieldName}`,
      });
      return `${fieldName}: ${captureByRef ? "*Value" : "Value"}`;
    });
    ctx.hoisted.push(`const ${envType} = struct { ${fields.join(", ")} };`);
    const initFields = captures.map((name) => {
      const ref = resolveVar(name, ctx);
      const fieldName = fieldNames.get(name)!;
      const captureByRef = !ref.address.startsWith("&");
      return `.${fieldName} = ${captureByRef ? ref.address : ref.value}`;
    }).join(", ");
    envInit = `runtime.allocEnv(${envType}, .{ ${initFields} })`;
  }

  const paramName = bindShadowingLocal(scope, "__match_value", ctx.state);
  const body = emitMatchWithScrutinee(expr, ctx, paramName, scope);

  ctx.hoisted.push(
    `fn ${lambdaName}(env_ptr: ?*anyopaque, __args: []const Value) Value {`,
  );
  if (captures.length > 0) {
    ctx.hoisted.push(
      indent(`const env: *${envType} = @ptrCast(@alignCast(env_ptr.?));`),
    );
  } else {
    ctx.hoisted.push(indent("_ = env_ptr;"));
  }
  ctx.hoisted.push(indent(`const ${paramName} = __args[0];`));
  ctx.hoisted.push(indent(`return ${body};`));
  ctx.hoisted.push("}");

  let debugName = lambdaName;
  const span = expr.span ?? expr.scrutinee.span;
  if (ctx.options.getSourceLocation && span) {
    const loc = ctx.options.getSourceLocation(span);
    if (loc) {
      debugName = `${lambdaName} (${loc.file}:${loc.line}:${loc.column})`;
      {
        const parts = loc.file.replace(/\\/g, "/").split("/");
        const fileName = parts[parts.length - 1];
        debugName = `${lambdaName} (${fileName}:${loc.line})`;
      }
    }
  }

  return `runtime.makeFunc(${lambdaName}, ${envInit}, "${debugName}")`;
}

function collectFreeVarsInMatchBody(
  expr: CoreExpr & { kind: "match" },
  bound: Set<string>,
): { freeVars: Set<string> } {
  const freeVars = new Set<string>();
  const addFreeVars = (node: CoreExpr, localBound: Set<string>) => {
    const collected = collectFreeVars(node, localBound).freeVars;
    for (const name of collected) {
      freeVars.add(name);
    }
  };
  for (const kase of expr.cases) {
    const caseBound = new Set(bound);
    for (const name of boundNamesInPattern(kase.pattern)) {
      caseBound.add(name);
    }
    if (kase.guard) addFreeVars(kase.guard, caseBound);
    addFreeVars(kase.body, caseBound);
  }
  if (expr.fallback) addFreeVars(expr.fallback, bound);
  return { freeVars };
}

function emitMatchCase(
  kase: CoreMatchCase,
  scrutineeRef: string,
  ctx: EmitContext,
  baseScope: Map<string, VarRef>,
  label: string,
  scrutineeTypeName?: string,
): string[] {
  const caseScope = new Map(baseScope);
  const usedVars = collectUsedVars(kase.body);
  if (kase.guard) {
    const guardUsed = collectUsedVars(kase.guard);
    for (const name of guardUsed) {
      usedVars.add(name);
    }
  }
  const { conditions, bindings } = emitPattern(
    kase.pattern,
    scrutineeRef,
    ctx,
    caseScope,
    usedVars,
    scrutineeTypeName,
  );
  const conditionExpr = conditions.length > 0
    ? conditions.map((cond) => `(${cond})`).join(" and ")
    : "true";
  const guardExpr = kase.guard
    ? emitExprWithScope(kase.guard, ctx, caseScope)
    : undefined;
  const bodyExpr = emitExprWithScope(kase.body, ctx, caseScope);

  const lines: string[] = [];
  lines.push(`if (${conditionExpr}) {`);
  const innerLines: string[] = [];
  innerLines.push(...bindings);
  for (const name of boundNamesInPattern(kase.pattern)) {
    if (usedVars.has(name)) {
      const ref = resolveName(caseScope, name, ctx.state);
      innerLines.push(`runtime.traceBinding("${name}", ${ref});`);
    }
  }
  if (guardExpr) {
    innerLines.push(`if (runtime.expectBool(${guardExpr})) {`);
    innerLines.push(indent(`break :${label} ${bodyExpr};`));
    innerLines.push("}");
  } else {
    innerLines.push(`break :${label} ${bodyExpr};`);
  }
  lines.push(...innerLines.map((line) => indent(line)));
  lines.push("}");
  return lines;
}

interface PatternEmission {
  conditions: string[];
  bindings: string[];
}

function emitPattern(
  pattern: CorePattern,
  valueRef: string,
  ctx: EmitContext,
  scope: Map<string, VarRef>,
  usedVars: Set<string>,
  overrideConstructorTypeName?: string,
): PatternEmission {
  const ref = `(${valueRef})`;
  switch (pattern.kind) {
    case "wildcard":
      return { conditions: [], bindings: [] };
    case "binding": {
      if (!usedVars.has(pattern.name)) {
        return {
          conditions: [],
          bindings: [`_ = ${ref};`],
        };
      }
      const name = bindShadowingLocal(scope, pattern.name, ctx.state);
      return {
        conditions: [],
        bindings: [`const ${name} = ${ref};`],
      };
    }
    case "pinned": {
      const existing = resolveVar(pattern.name, ctx).value;
      return {
        conditions: [`runtime.valueEquals(${ref}, ${existing})`],
        bindings: [],
      };
    }
    case "literal": {
      const literalExpr = emitLiteral({ literal: pattern.literal }, ctx);
      return {
        conditions: [`runtime.valueEquals(${ref}, ${literalExpr})`],
        bindings: [],
      };
    }
    case "tuple": {
      const length = pattern.elements.length;
      const conditions = [
        `runtime.isTuple(${ref}, ${length})`,
      ];
      const bindings: string[] = [];
      for (let index = 0; index < length; index += 1) {
        const nested = emitPattern(
          pattern.elements[index],
          `runtime.tupleGet(${ref}, ${index})`,
          ctx,
          scope,
          usedVars,
          undefined,
        );
        conditions.push(...nested.conditions);
        bindings.push(...nested.bindings);
      }
      return { conditions, bindings };
    }
    case "constructor": {
      const typeName = overrideConstructorTypeName ?? pattern.typeName;
      const conditions = [
        `runtime.isData(${ref}, "${typeName}", "${pattern.constructor}")`,
      ];
      const bindings: string[] = [];
      
      for (let index = 0; index < pattern.fields.length; index += 1) {
        const fieldRef = `runtime.dataField(${ref}, ${index})`;
        const nested = emitPattern(
          pattern.fields[index],
          fieldRef,
          ctx,
          scope,
          usedVars,
          undefined,
        );
        conditions.push(...nested.conditions);
        bindings.push(...nested.bindings);
      }
      return { conditions, bindings };
    }
    case "all_errors": {
      return {
        conditions: [
          `runtime.isData(${ref}, "${pattern.resultTypeName}", "Err")`,
        ],
        bindings: [],
      };
    }
    default: {
      const _exhaustive: never = pattern;
      void _exhaustive;
      throw new Error(
        `Unsupported pattern kind '${(pattern as CorePattern).kind}'`,
      );
    }
  }
}

function emitExprWithScope(
  expr: CoreExpr,
  ctx: EmitContext,
  scope: Map<string, VarRef>,
  nameHint?: string,
): string {
  const previous = ctx.scope;
  ctx.scope = scope;
  try {
    return emitExpr(expr, ctx, nameHint);
  } finally {
    ctx.scope = previous;
  }
}

function emitPrim(
  op: CorePrimOp,
  args: readonly CoreExpr[],
  ctx: EmitContext,
): string {
  const emitArg = (index: number) => emitExpr(args[index], ctx);

  switch (op) {
    case "int_add":
      return `runtime.intAdd(${emitArg(0)}, ${emitArg(1)})`;
    case "int_sub":
      return `runtime.intSub(${emitArg(0)}, ${emitArg(1)})`;
    case "int_mul":
      return `runtime.intMul(${emitArg(0)}, ${emitArg(1)})`;
    case "int_div":
      return `runtime.intDiv(${emitArg(0)}, ${emitArg(1)})`;
    case "int_eq":
      return `runtime.intEq(${emitArg(0)}, ${emitArg(1)})`;
    case "int_ne":
      return `runtime.intNe(${emitArg(0)}, ${emitArg(1)})`;
    case "int_lt":
      return `runtime.intLt(${emitArg(0)}, ${emitArg(1)})`;
    case "int_le":
      return `runtime.intLe(${emitArg(0)}, ${emitArg(1)})`;
    case "int_gt":
      return `runtime.intGt(${emitArg(0)}, ${emitArg(1)})`;
    case "int_ge":
      return `runtime.intGe(${emitArg(0)}, ${emitArg(1)})`;
    case "int_cmp":
      return `runtime.intCmp(${emitArg(0)}, ${emitArg(1)})`;
    case "bool_and":
      return `runtime.boolAnd(${emitArg(0)}, ${emitArg(1)})`;
    case "bool_or":
      return `runtime.boolOr(${emitArg(0)}, ${emitArg(1)})`;
    case "bool_not":
      return `runtime.boolNot(${emitArg(0)})`;
    case "char_eq":
      return `runtime.intEq(${emitArg(0)}, ${emitArg(1)})`;
    case "string_length":
      return `runtime.stringLength(${emitArg(0)})`;
    case "string_slice":
      return `runtime.stringSlice(${emitArg(0)}, ${emitArg(1)}, ${emitArg(2)})`;
    case "native_print":
      return `runtime.nativePrintValue(${emitArg(0)})`;
    case "record_get": {
      const target = emitArg(0);
      const field = args[1];
      if (field.kind !== "literal" || field.literal.kind !== "string") {
        throw new Error("record_get expects string literal field");
      }
      const fieldName = JSON.stringify(field.literal.value);
      return `runtime.recordGet(${target}, ${fieldName})`;
    }
    case "panic":
      return `runtime.panic(${emitArg(0)})`;
    case "address_of":
      // address_of is handled specially in raw mode
      throw new Error("address_of should be handled in raw mode emitter");
    default:
      throw new Error(`Unsupported primitive op '${op}'`);
  }
}

function resolveVar(name: string, ctx: EmitContext): VarRef {
  const direct = ctx.scope.get(name);
  if (direct) {
    return direct;
  }
  const alias = PRELUDE_OPERATOR_ALIASES.get(name) ??
    PRELUDE_PREFIX_ALIASES.get(name);
  if (alias) {
    const aliasRef = ctx.scope.get(alias);
    if (aliasRef) {
      return aliasRef;
    }
  }
  const runtimeName = makeIdentifierBase(name);
  return {
    value: `runtime.${runtimeName}`,
    address: `&runtime.${runtimeName}`,
  };
}

function resolveName(
  scope: Map<string, VarRef>,
  original: string,
  state: NameState,
): string {
  const existing = scope.get(original);
  if (existing) {
    return existing.value;
  }
  return bindLocal(scope, original, state);
}

function bindLocal(
  scope: Map<string, VarRef>,
  original: string,
  state: NameState,
): string {
  const existing = scope.get(original);
  if (existing) return existing.value;
  const sanitized = sanitizeIdentifier(original, state);
  scope.set(original, { value: sanitized, address: `&${sanitized}` });
  return sanitized;
}

function bindShadowingLocal(
  scope: Map<string, VarRef>,
  original: string,
  state: NameState,
): string {
  const sanitized = sanitizeIdentifier(original, state);
  scope.set(original, { value: sanitized, address: `&${sanitized}` });
  return sanitized;
}

function sanitizeIdentifier(name: string, state: NameState): string {
  const base = makeIdentifierBase(name);
  let candidate = base;
  while (RESERVED.has(candidate) || state.used.has(candidate)) {
    candidate = `${base}_${state.counter++}`;
  }
  state.used.add(candidate);
  return candidate;
}

function sanitizeExportName(
  desired: string,
  localName: string,
  state: NameState,
): string {
  if (desired === "_") {
    return "_";
  }
  let candidate = makeIdentifierBase(desired);
  if (candidate === "") {
    candidate = "_";
  }
  const formatExport = (name: string): string =>
    RESERVED.has(name) ? `@"${name}"` : name;
  const formattedCandidate = formatExport(candidate);
  if (formattedCandidate === localName) {
    return formattedCandidate;
  }
  let unique = candidate;
  let counter = 0;
  while (state.used.has(formatExport(unique))) {
    unique = `${candidate}_${counter++}`;
  }
  const exported = formatExport(unique);
  state.used.add(exported);
  return exported;
}

function allocateTempName(state: NameState, base: string): string {
  return sanitizeIdentifier(base, state);
}

function allocateLabel(state: NameState): string {
  return allocateTempName(state, "__blk");
}

function makeIdentifierBase(name: string): string {
  const cleaned = name.replace(/[^A-Za-z0-9_]/g, "_");
  if (/^[A-Za-z_]/.test(cleaned)) {
    return cleaned;
  }
  return `_${cleaned || "name"}`;
}

function indent(text: string): string {
  return text.split("\n").map((line) => (line.length > 0 ? `  ${line}` : line))
    .join("\n");
}

function findModuleInGraph(
  graph: CoreModuleGraph,
  importSource: string,
): CoreModule | undefined {
  let target = importSource.replace(/\\/g, "/");
  // Try converting .zig to .wm
  if (target.endsWith(".zig")) {
    target = target.slice(0, -4) + ".wm";
  }

  // Direct match check
  if (graph.modules.has(target)) return graph.modules.get(target);

  // Scan keys
  let bestKey: string | undefined;
  let maxMatch = 0;

  const targetParts = target.split("/");

  for (const key of graph.modules.keys()) {
    const keyParts = key.replace(/\\/g, "/").split("/");

    let matchLen = 0;
    let i = 1;
    while (i <= targetParts.length && i <= keyParts.length) {
      const t = targetParts[targetParts.length - i].toLowerCase();
      const k = keyParts[keyParts.length - i].toLowerCase();
      if (t !== k) break;
      matchLen++;
      i++;
    }

    // Prefer exact filename match at least
    if (matchLen > maxMatch) {
      maxMatch = matchLen;
      bestKey = key;
    }
  }

  // Require at least filename match.
  if (bestKey && maxMatch >= 1) {
    return graph.modules.get(bestKey);
  }

  return undefined;
}
