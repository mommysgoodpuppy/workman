import {
  dirname,
  extname,
  relative,
} from "../../../src/io.ts";
import { isCarrierType } from "../../../src/types.ts";
import type {
  CoreExpr,
  CoreLiteral,
  CoreMatchCase,
  CoreModule,
  CoreModuleGraph,
  CorePattern,
  CorePrimOp,
  CoreTypeConstructor,
  CoreTypeDeclaration,
} from "../ir/core.ts";

interface NameState {
  used: Set<string>;
  counter: number;
}

interface VarRef {
  value: string;
  address: string;
}

interface EmitContext {
  state: NameState;
  scope: Map<string, VarRef>;
  options: EmitModuleOptions;
  modulePath: string;
  hoisted: string[];
}

export interface EmitModuleOptions {
  readonly extension?: string;
  readonly runtimeModule?: string;
  readonly baseDir?: string; // directory of the emitted module file
  readonly forcedValueExports?: readonly string[];
  readonly preludeModule?: {
    specifier: string;
    names: readonly string[];
  };
  readonly invokeEntrypoint?: boolean;
}

const RESERVED = new Set<string>([
  "align",
  "allowzero",
  "and",
  "anyframe",
  "anytype",
  "asm",
  "async",
  "await",
  "break",
  "catch",
  "comptime",
  "const",
  "continue",
  "defer",
  "else",
  "enum",
  "errdefer",
  "error",
  "export",
  "extern",
  "false",
  "for",
  "if",
  "inline",
  "linksection",
  "noalias",
  "noinline",
  "nosuspend",
  "opaque",
  "or",
  "orelse",
  "packed",
  "pub",
  "resume",
  "return",
  "struct",
  "suspend",
  "switch",
  "test",
  "threadlocal",
  "true",
  "try",
  "union",
  "unreachable",
  "usingnamespace",
  "var",
  "volatile",
  "while",
  "_",
  "__wm_init",
  "__wm_init_state",
]);

const INIT_FN = "__wm_init";
const INIT_STATE = "__wm_init_state";

const PRELUDE_OPERATOR_ALIASES = new Map<string, string>([
  ["__op_+", "add"],
  ["__op_-", "sub"],
  ["__op_*", "mul"],
  ["__op_/", "div"],
  ["__op_==", "eq"],
  ["__op_!=", "neq"],
  ["__op_<", "lt"],
  ["__op_>", "gt"],
  ["__op_<=", "lte"],
  ["__op_>=", "gte"],
  ["__op_&&", "boolAnd"],
  ["__op_||", "boolOr"],
]);

const PRELUDE_PREFIX_ALIASES = new Map<string, string>([
  ["__prefix_!", "not"],
]);

export function emitModule(
  module: CoreModule,
  graph: CoreModuleGraph,
  options: EmitModuleOptions = {},
): string {
  const extension = options.extension ?? ".zig";
  const runtimeModule = options.runtimeModule ?? "./runtime.zig";

  const state: NameState = { used: new Set(), counter: 0 };
  const scope = new Map<string, VarRef>();
  const ctx: EmitContext = {
    state,
    scope,
    options: { extension, runtimeModule },
    modulePath: module.path,
    hoisted: [],
  };

  preallocateNames(module, coreGraphImports(module), ctx);

  const lines: string[] = [];
  lines.push("// Generated by Workman compiler (Zig)");
  lines.push(`const runtime = @import("${runtimeModule}");`);
  lines.push(`const Value = runtime.Value;`);

  const exportSet = buildExportSet(module);
  const forcedValueExports = new Set(options.forcedValueExports ?? []);
  const initLines: string[] = [];
  const importLines = emitImports(module, ctx, exportSet, initLines);
  if (importLines.length > 0) {
    lines.push(...importLines);
  }

  const preludeLines = emitPreludeImports(ctx, options.preludeModule, initLines);
  if (preludeLines.length > 0) {
    lines.push(...preludeLines);
  }

  lines.push(`var ${INIT_STATE}: u8 = 0;`);

  const typeLines = emitTypeDeclarations(module.typeDeclarations, ctx, initLines);
  const valueLines: string[] = [];
  for (const binding of module.values) {
    const bindingRef = resolveName(ctx.scope, binding.name, ctx.state);
    const expr = emitExpr(binding.value, ctx);
    const isExported = exportSet.has(binding.name) ||
      forcedValueExports.has(binding.name);
    valueLines.push(
      `${isExported ? "pub " : ""}var ${bindingRef}: Value = undefined;`,
    );
    initLines.push(`${bindingRef} = ${expr};`);
  }
  const exportLines = emitExports(module, ctx, exportSet, initLines);
  const mainLines: string[] = [];
  const hasMain = module.values.some((binding) => binding.name === "main");
  if (
    module.path === graph.entry &&
    (options.invokeEntrypoint ?? true) &&
    hasMain
  ) {
    const mainRef = resolveVar("main", ctx).value;
    mainLines.push("");
    mainLines.push("pub fn main() void {");
    mainLines.push(indent(`${INIT_FN}();`));
    mainLines.push(indent(`_ = runtime.call(${mainRef}, &[_]Value{});`));
    mainLines.push("}");
  }

  if (ctx.hoisted.length > 0) {
    lines.push(...ctx.hoisted);
  }
  if (typeLines.length > 0) {
    lines.push(...typeLines);
  }
  if (valueLines.length > 0) {
    lines.push(...valueLines);
  }
  if (exportLines.length > 0) {
    lines.push(...exportLines);
  }
  lines.push("");
  lines.push(`pub fn ${INIT_FN}() void {`);
  lines.push(indent(`if (${INIT_STATE} == 2) return;`));
  lines.push(indent(`if (${INIT_STATE} == 1) return;`));
  lines.push(indent(`${INIT_STATE} = 1;`));
  if (initLines.length > 0) {
    for (const initLine of initLines) {
      lines.push(indent(initLine));
    }
  }
  lines.push(indent(`${INIT_STATE} = 2;`));
  lines.push("}");
  if (mainLines.length > 0) {
    lines.push(...mainLines);
  }

  return `${lines.join("\n")}\n`;
}

function buildExportSet(module: CoreModule): Set<string> {
  const exported = new Set<string>();
  for (const value of module.values) {
    if (value.exported) exported.add(value.name);
  }
  for (const decl of module.typeDeclarations) {
    for (const ctor of decl.constructors) {
      if (ctor.exported) exported.add(ctor.name);
    }
  }
  for (const exp of module.exports) {
    if (exp.kind === "value") {
      exported.add(exp.local);
    } else if (exp.kind === "constructor") {
      exported.add(exp.ctor);
    }
  }
  return exported;
}

function coreGraphImports(module: CoreModule): string[] {
  const names: string[] = [];
  for (const record of module.imports) {
    for (const spec of record.specifiers) {
      names.push(spec.local);
    }
  }
  return names;
}

function preallocateNames(
  module: CoreModule,
  importNames: string[],
  ctx: EmitContext,
): void {
  for (const name of importNames) {
    bindLocal(ctx.scope, name, ctx.state);
  }
  for (const decl of module.typeDeclarations) {
    for (const ctor of decl.constructors) {
      bindLocal(ctx.scope, ctor.name, ctx.state);
    }
  }
  for (const binding of module.values) {
    bindLocal(ctx.scope, binding.name, ctx.state);
  }
}

function emitImports(
  module: CoreModule,
  ctx: EmitContext,
  exportSet: Set<string>,
  initLines: string[],
): string[] {
  if (module.imports.length === 0) return [];

  const currentDir = ctx.options.baseDir ?? dirname(module.path);
  const lines: string[] = [];
  let importCounter = 0;
  for (const entry of module.imports) {
    const alias = allocateTempName(ctx.state, `__mod_${importCounter++}`);
    const importPath = makeImportPath(
      currentDir,
      entry.source,
      ctx.options.extension ?? ".zig",
    );
    lines.push(`const ${alias} = @import("${importPath}");`);
    initLines.push(`${alias}.${INIT_FN}();`);
    for (const spec of entry.specifiers) {
      const local = resolveName(ctx.scope, spec.local, ctx.state);
      const exported = exportSet.has(spec.local) ? "pub " : "";
      lines.push(`${exported}var ${local}: Value = undefined;`);
      initLines.push(`${local} = ${alias}.${spec.imported};`);
    }
  }

  return lines;
}

function emitPreludeImports(
  ctx: EmitContext,
  prelude?: { specifier: string; names: readonly string[] },
  initLines: string[] = [],
): string[] {
  if (!prelude) return [];
  const lines: string[] = [];
  const alias = allocateTempName(ctx.state, "__prelude");
  lines.push(`const ${alias} = @import("${prelude.specifier}");`);
  initLines.push(`${alias}.${INIT_FN}();`);
  for (const name of prelude.names) {
    if (ctx.scope.has(name)) continue;
    const local = resolveName(ctx.scope, name, ctx.state);
    lines.push(`var ${local}: Value = undefined;`);
    initLines.push(`${local} = ${alias}.${name};`);
  }
  return lines;
}

function makeImportPath(
  fromDir: string,
  target: string,
  extension: string,
): string {
  let rel = relative(fromDir, target);
  if (rel === "") rel = ".";
  if (!rel.startsWith(".")) {
    rel = `./${rel}`;
  }
  rel = rel.replace(/\\/g, "/");
  const existingExt = extname(rel);
  if (existingExt === "") {
    rel = `${rel}${extension}`;
  } else if (existingExt === ".wm") {
    rel = `${rel.slice(0, rel.length - existingExt.length)}${extension}`;
  }
  return rel;
}


function emitTypeDeclarations(
  declarations: readonly CoreTypeDeclaration[],
  ctx: EmitContext,
  initLines: string[],
): string[] {
  const lines: string[] = [];
  for (const decl of declarations) {
    for (const ctor of decl.constructors) {
      lines.push(...emitConstructor(decl, ctor, ctx, initLines));
    }
    if (
      decl.infectious && decl.infectious.valueConstructor &&
      decl.infectious.effectConstructors
    ) {
      const effectCtors = decl.infectious.effectConstructors
        .map((ctor) => `"${ctor}"`)
        .join(", ");
      initLines.push(
        `runtime.registerInfectiousType("${decl.name}", "${decl.infectious.valueConstructor}", &[_][]const u8{ ${effectCtors} });`,
      );
    }
  }
  return lines;
}

function emitConstructor(
  decl: CoreTypeDeclaration,
  ctor: CoreTypeConstructor,
  ctx: EmitContext,
  initLines: string[],
): string[] {
  const name = resolveName(ctx.scope, ctor.name, ctx.state);
  if (ctor.arity === 0) {
    initLines.push(
      `${name} = runtime.makeData("${decl.name}", "${ctor.name}", &[_]Value{});`,
    );
    return [
      `${ctor.exported ? "pub " : ""}var ${name}: Value = undefined;`,
    ];
  }

  const fnName = allocateTempName(ctx.state, `__ctor_${ctor.name}`);
  const params = Array.from({ length: ctor.arity }, (_, i) => `args[${i}]`);
  const fields = params.join(", ");
  const body = `return runtime.makeData("${decl.name}", "${ctor.name}", &[_]Value{ ${fields} });`;

  ctx.hoisted.push(
    `fn ${fnName}(env_ptr: ?*anyopaque, args: []const Value) Value {`,
  );
  ctx.hoisted.push(indent("_ = env_ptr;"));
  ctx.hoisted.push(indent(body));
  ctx.hoisted.push("}");

  initLines.push(`${name} = runtime.makeFunc(${fnName}, null);`);
  return [
    `${ctor.exported ? "pub " : ""}var ${name}: Value = undefined;`,
  ];
}

function emitExports(
  module: CoreModule,
  ctx: EmitContext,
  exportSet: Set<string>,
  initLines: string[],
): string[] {
  const lines: string[] = [];
  const exportedNames = new Set<string>();
  for (const exp of module.exports) {
    if (exp.kind === "type") continue;
    const localOriginal = exp.kind === "value"
      ? exp.local
      : (ctx.scope.has(exp.ctor) ? exp.ctor : exp.exported);
    const localName = resolveName(ctx.scope, localOriginal, ctx.state);
    const exported = sanitizeExportName(exp.exported, localName, ctx.state);
    if (exported === localName) {
      continue;
    }
    if (exportedNames.has(exported)) continue;
    lines.push(`pub var ${exported}: Value = undefined;`);
    initLines.push(`${exported} = ${localName};`);
    exportedNames.add(exported);
  }
  return lines;
}

function emitExpr(expr: CoreExpr, ctx: EmitContext): string {
  switch (expr.kind) {
    case "literal":
      return emitLiteral(expr, ctx);
    case "var":
      return resolveVar(expr.name, ctx).value;
    case "tuple":
      return `runtime.makeTuple(&[_]Value{ ${
        expr.elements.map((el) => emitExpr(el, ctx)).join(", ")
      } })`;
    case "record":
      return emitRecord(expr, ctx);
    case "tuple_get":
      return `runtime.tupleGet(${emitExpr(expr.target, ctx)}, ${expr.index})`;
    case "data":
      return emitData(expr, ctx);
    case "lambda":
      return emitLambda(expr, ctx);
    case "call":
      return emitCall(expr, ctx);
    case "let":
      return emitLet(expr, ctx);
    case "let_rec":
      return emitLetRec(expr, ctx);
    case "prim":
      return emitPrim(expr.op, expr.args, ctx);
    case "if":
      return `if (runtime.expectBool(${emitExpr(expr.condition, ctx)})) ${
        emitExpr(expr.thenBranch, ctx)
      } else ${emitExpr(expr.elseBranch, ctx)}`;
    case "match":
      if (isCarrierType(expr.scrutinee.type)) {
        const scrutineeCode = emitExpr(expr.scrutinee, ctx);
        const dischargesCarrier = Boolean(expr.effectRowCoverage?.dischargesResult);
        const patternsHandleCarrier = expr.cases.some((kase) =>
          hasResultConstructorPattern(kase.pattern) ||
          kase.pattern.kind === "all_errors"
        );
        let matchLambda = emitMatchLambda(expr, ctx);
        if (patternsHandleCarrier) {
          matchLambda = `runtime.markResultHandler(${matchLambda}, &[_]usize{ 0 })`;
        }
        if (dischargesCarrier && patternsHandleCarrier) {
          return `runtime.call(${matchLambda}, &[_]Value{ ${scrutineeCode} })`;
        }
        return `runtime.callInfectious(${matchLambda}, &[_]Value{ ${scrutineeCode} })`;
      }
      return emitMatch(expr, ctx);
    default:
      throw new Error(
        `Unsupported expression kind '${(expr as CoreExpr).kind}'`,
      );
  }
}

function emitLiteral(
  expr: { literal: { kind: string; value?: unknown } },
  _ctx: EmitContext,
): string {
  switch (expr.literal.kind) {
    case "unit":
      return "runtime.makeUnit()";
    case "int":
    case "char":
      return `runtime.makeInt(${String(expr.literal.value)})`;
    case "bool":
      return expr.literal.value ? "runtime.makeBool(true)" : "runtime.makeBool(false)";
    case "string":
      return `runtime.makeString(${JSON.stringify(expr.literal.value)})`;
    default:
      throw new Error(`Unsupported literal kind '${expr.literal.kind}'`);
  }
}

function emitRecord(
  expr: CoreExpr & { kind: "record" },
  ctx: EmitContext,
): string {
  if (expr.fields.length === 0) {
    return "runtime.makeRecord(&[_]runtime.RecordField{})";
  }
  const fields = expr.fields.map((field) => {
    const value = emitExpr(field.value, ctx);
    return `.{ .name = ${JSON.stringify(field.name)}, .value = ${value} }`;
  }).join(", ");
  return `runtime.makeRecord(&[_]runtime.RecordField{ ${fields} })`;
}

function emitData(expr: CoreExpr & { kind: "data" }, ctx: EmitContext): string {
  const fields = expr.fields.map((field) => emitExpr(field, ctx)).join(", ");
  return `runtime.makeData("${expr.typeName}", "${expr.constructor}", &[_]Value{ ${fields} })`;
}

function emitLambda(
  expr: CoreExpr & { kind: "lambda" },
  ctx: EmitContext,
): string {
  const handledParams = detectHandledResultParams(expr, expr.params);
  const usedVars = collectUsedVars(expr.body);
  const { freeVars } = collectFreeVars(expr.body, new Set(expr.params));
  const captures = Array.from(freeVars).filter((name) =>
    ctx.scope.has(name)
  );
  const lambdaName = allocateTempName(ctx.state, "__lambda");

  let envType: string | undefined;
  let envInit = "null";
  const scope = new Map(ctx.scope);

  if (captures.length > 0) {
    envType = allocateTempName(ctx.state, "__env");
    const fieldNames = new Map<string, string>();
    const fields = captures.map((name) => {
      const fieldName = sanitizeIdentifier(name, ctx.state);
      fieldNames.set(name, fieldName);
      scope.set(name, {
        value: `env.${fieldName}.*`,
        address: `env.${fieldName}`,
      });
      return `${fieldName}: *const Value`;
    });
    ctx.hoisted.push(`const ${envType} = struct { ${fields.join(", ")} };`);
    const initFields = captures.map((name) => {
      const ref = resolveVar(name, ctx);
      const fieldName = fieldNames.get(name)!;
      return `.${fieldName} = ${ref.address}`;
    }).join(", ");
    envInit = `runtime.allocEnv(${envType}, .{ ${initFields} })`;
  }

  const params = expr.params.flatMap((param, index) => {
    if (!usedVars.has(param)) return [];
    const local = bindShadowingLocal(scope, param, ctx.state);
    return [{ name: local, index }];
  });
  const body = emitExprWithScope(expr.body, ctx, scope);

  ctx.hoisted.push(
    `fn ${lambdaName}(env_ptr: ?*anyopaque, args: []const Value) Value {`,
  );
  if (captures.length > 0) {
    ctx.hoisted.push(
      indent(`const env: *${envType} = @ptrCast(@alignCast(env_ptr.?));`),
    );
  } else {
    ctx.hoisted.push(indent("_ = env_ptr;"));
  }
  if (params.length === 0) {
    ctx.hoisted.push(indent("_ = args;"));
  }
  for (const param of params) {
    ctx.hoisted.push(
      indent(`const ${param.name} = args[${param.index}];`),
    );
  }
  ctx.hoisted.push(indent(`return ${body};`));
  ctx.hoisted.push("}");

  const funcValue = `runtime.makeFunc(${lambdaName}, ${envInit})`;
  if (handledParams.length > 0) {
    return `runtime.markResultHandler(${funcValue}, &[_]usize{ ${
      handledParams.join(", ")
    } })`;
  }
  return funcValue;
}

function collectFreeVars(
  expr: CoreExpr,
  bound: Set<string>,
): { freeVars: Set<string> } {
  const freeVars = new Set<string>();

  function visit(node: CoreExpr, localBound: Set<string>): void {
    switch (node.kind) {
      case "literal":
        return;
      case "var":
        if (!localBound.has(node.name)) {
          freeVars.add(node.name);
        }
        return;
      case "tuple":
        node.elements.forEach((el) => visit(el, localBound));
        return;
      case "record":
        node.fields.forEach((field) => visit(field.value, localBound));
        return;
      case "tuple_get":
        visit(node.target, localBound);
        return;
      case "data":
        node.fields.forEach((field) => visit(field, localBound));
        return;
      case "lambda": {
        const nextBound = new Set(localBound);
        node.params.forEach((p) => nextBound.add(p));
        visit(node.body, nextBound);
        return;
      }
      case "call":
        visit(node.callee, localBound);
        node.args.forEach((arg) => visit(arg, localBound));
        return;
      case "let": {
        visit(node.binding.value, localBound);
        const nextBound = new Set(localBound);
        nextBound.add(node.binding.name);
        visit(node.body, nextBound);
        return;
      }
      case "let_rec": {
        const nextBound = new Set(localBound);
        node.bindings.forEach((binding) => nextBound.add(binding.name));
        node.bindings.forEach((binding) => visit(binding.value, nextBound));
        visit(node.body, nextBound);
        return;
      }
      case "if":
        visit(node.condition, localBound);
        visit(node.thenBranch, localBound);
        visit(node.elseBranch, localBound);
        return;
      case "prim":
        node.args.forEach((arg) => visit(arg, localBound));
        return;
      case "match": {
        visit(node.scrutinee, localBound);
        for (const kase of node.cases) {
          const caseBound = new Set(localBound);
          for (const name of boundNamesInPattern(kase.pattern)) {
            caseBound.add(name);
          }
          if (kase.guard) visit(kase.guard, caseBound);
          visit(kase.body, caseBound);
        }
        if (node.fallback) visit(node.fallback, localBound);
        return;
      }
      default:
        return;
    }
  }

  visit(expr, bound);
  return { freeVars };
}

function collectUsedVars(expr: CoreExpr): Set<string> {
  const used = new Set<string>();

  function visit(node: CoreExpr): void {
    switch (node.kind) {
      case "literal":
        return;
      case "var":
        used.add(node.name);
        return;
      case "tuple":
        node.elements.forEach(visit);
        return;
      case "record":
        node.fields.forEach((field) => visit(field.value));
        return;
      case "tuple_get":
        visit(node.target);
        return;
      case "data":
        node.fields.forEach(visit);
        return;
      case "lambda":
        visit(node.body);
        return;
      case "call":
        visit(node.callee);
        node.args.forEach(visit);
        return;
      case "let":
        visit(node.binding.value);
        visit(node.body);
        return;
      case "let_rec":
        node.bindings.forEach((binding) => visit(binding.value));
        visit(node.body);
        return;
      case "if":
        visit(node.condition);
        visit(node.thenBranch);
        visit(node.elseBranch);
        return;
      case "prim":
        node.args.forEach(visit);
        return;
      case "match":
        visit(node.scrutinee);
        node.cases.forEach((kase) => {
          if (kase.guard) visit(kase.guard);
          visit(kase.body);
        });
        if (node.fallback) visit(node.fallback);
        return;
      default:
        return;
    }
  }

  visit(expr);
  return used;
}

function boundNamesInPattern(pattern: CorePattern): string[] {
  switch (pattern.kind) {
    case "binding":
      return [pattern.name];
    case "tuple":
      return pattern.elements.flatMap(boundNamesInPattern);
    case "constructor":
      return pattern.fields.flatMap(boundNamesInPattern);
    case "wildcard":
    case "literal":
    case "pinned":
    case "all_errors":
      return [];
    default:
      return [];
  }
}

function emitCall(expr: CoreExpr & { kind: "call" }, ctx: EmitContext): string {
  const callee = emitExpr(expr.callee, ctx);
  const args = expr.args.map((arg) => emitExpr(arg, ctx)).join(", ");
  const resultIsInfectious = isCarrierType(expr.type);
  const calleeIsInfectious = isCarrierType(expr.callee.type);
  const anyArgIsInfectious = expr.args.some((arg) => isCarrierType(arg.type));
  if (!resultIsInfectious && !calleeIsInfectious && !anyArgIsInfectious) {
    return `runtime.call(${callee}, &[_]Value{ ${args} })`;
  }
  return `runtime.callInfectious(${callee}, &[_]Value{ ${args} })`;
}

function emitLet(expr: CoreExpr & { kind: "let" }, ctx: EmitContext): string {
  const usedVars = collectUsedVars(expr.body);
  const innerScope = new Map(ctx.scope);
  const bindingName = bindShadowingLocal(
    innerScope,
    expr.binding.name,
    ctx.state,
  );
  const valueScope = expr.binding.isRecursive ? innerScope : ctx.scope;
  const valueCode = emitExprWithScope(expr.binding.value, ctx, valueScope);
  const bodyCode = emitExprWithScope(expr.body, ctx, innerScope);
  const label = allocateLabel(ctx.state);
  const isStmt = expr.binding.name.startsWith("__stmt");
  const isUsed = usedVars.has(expr.binding.name);
  if (isStmt || (!isUsed && !expr.binding.isRecursive)) {
    return `${label}: {\n${indent(`_ = ${valueCode};`)}\n${
      indent(`break :${label} ${bodyCode};`)
    }\n}`;
  }
  return `${label}: {\n${indent(`const ${bindingName} = ${valueCode};`)}\n${
    indent(`break :${label} ${bodyCode};`)
  }\n}`;
}

function emitLetRec(
  expr: CoreExpr & { kind: "let_rec" },
  ctx: EmitContext,
): string {
  const usedVars = collectUsedVars(expr.body);
  for (const binding of expr.bindings) {
    const bindingUsed = collectUsedVars(binding.value);
    for (const name of bindingUsed) {
      usedVars.add(name);
    }
  }
  const innerScope = new Map(ctx.scope);
  const boxNames = new Map<string, string>();
  for (const binding of expr.bindings) {
    const boxName = allocateTempName(ctx.state, `${binding.name}_box`);
    innerScope.set(binding.name, {
      value: `${boxName}.*`,
      address: boxName,
    });
    boxNames.set(binding.name, boxName);
  }
  const lines: string[] = [];
  for (const binding of expr.bindings) {
    const boxName = boxNames.get(binding.name)!;
    lines.push(`const ${boxName} = runtime.allocValue();`);
    lines.push(`${boxName}.* = runtime.makeUnit();`);
  }
  for (const binding of expr.bindings) {
    const value = emitExprWithScope(binding.value, ctx, innerScope);
    const boxName = boxNames.get(binding.name)!;
    lines.push(`${boxName}.* = ${value};`);
  }
  for (const binding of expr.bindings) {
    if (!usedVars.has(binding.name)) {
      const boxName = boxNames.get(binding.name)!;
      lines.push(`_ = ${boxName};`);
    }
  }
  const body = emitExprWithScope(expr.body, ctx, innerScope);
  const label = allocateLabel(ctx.state);
  lines.push(`break :${label} ${body};`);
  const bodyLines = lines.map(indent).join("\n");
  return `${label}: {\n${bodyLines}\n}`;
}

function emitMatch(
  expr: CoreExpr & { kind: "match" },
  ctx: EmitContext,
): string {
  const scrutineeCode = emitExpr(expr.scrutinee, ctx);
  return emitMatchWithScrutinee(expr, ctx, scrutineeCode);
}

function emitMatchWithScrutinee(
  expr: CoreExpr & { kind: "match" },
  ctx: EmitContext,
  scrutineeCode: string,
  baseScope: Map<string, VarRef> = new Map(ctx.scope),
): string {
  const scrutineeTemp = allocateTempName(ctx.state, "__match_scrutinee");
  const scrutineeTypeName = expr.scrutinee.type.kind === "constructor"
    ? expr.scrutinee.type.name
    : undefined;
  const label = allocateLabel(ctx.state);
  const lines: string[] = [];
  lines.push(`const ${scrutineeTemp} = ${scrutineeCode};`);
  for (const kase of expr.cases) {
    lines.push(
      ...emitMatchCase(
        kase,
        scrutineeTemp,
        ctx,
        baseScope,
        label,
        scrutineeTypeName,
      ),
    );
  }
  if (expr.fallback) {
    const fallbackExpr = emitExprWithScope(expr.fallback, ctx, baseScope);
    lines.push(`break :${label} ${fallbackExpr};`);
  } else {
    lines.push(`break :${label} runtime.nonExhaustiveMatch(${scrutineeTemp});`);
  }
  const body = lines.map(indent).join("\n");
  return `${label}: {\n${body}\n}`;
}

function emitMatchLambda(
  expr: CoreExpr & { kind: "match" },
  ctx: EmitContext,
): string {
  const { freeVars } = collectFreeVarsInMatchBody(expr, new Set());
  const captures = Array.from(freeVars).filter((name) => ctx.scope.has(name));
  const lambdaName = allocateTempName(ctx.state, "__match_lambda");

  let envType: string | undefined;
  let envInit = "null";
  const scope = new Map(ctx.scope);

  if (captures.length > 0) {
    envType = allocateTempName(ctx.state, "__env");
    const fieldNames = new Map<string, string>();
    const fields = captures.map((name) => {
      const fieldName = sanitizeIdentifier(name, ctx.state);
      fieldNames.set(name, fieldName);
      scope.set(name, {
        value: `env.${fieldName}.*`,
        address: `env.${fieldName}`,
      });
      return `${fieldName}: *const Value`;
    });
    ctx.hoisted.push(`const ${envType} = struct { ${fields.join(", ")} };`);
    const initFields = captures.map((name) => {
      const ref = resolveVar(name, ctx);
      const fieldName = fieldNames.get(name)!;
      return `.${fieldName} = ${ref.address}`;
    }).join(", ");
    envInit = `runtime.allocEnv(${envType}, .{ ${initFields} })`;
  }

  const paramName = bindShadowingLocal(scope, "__match_value", ctx.state);
  const body = emitMatchWithScrutinee(expr, ctx, paramName, scope);

  ctx.hoisted.push(
    `fn ${lambdaName}(env_ptr: ?*anyopaque, args: []const Value) Value {`,
  );
  if (captures.length > 0) {
    ctx.hoisted.push(
      indent(`const env: *${envType} = @ptrCast(@alignCast(env_ptr.?));`),
    );
  } else {
    ctx.hoisted.push(indent("_ = env_ptr;"));
  }
  ctx.hoisted.push(indent(`const ${paramName} = args[0];`));
  ctx.hoisted.push(indent(`return ${body};`));
  ctx.hoisted.push("}");

  return `runtime.makeFunc(${lambdaName}, ${envInit})`;
}

function collectFreeVarsInMatchBody(
  expr: CoreExpr & { kind: "match" },
  bound: Set<string>,
): { freeVars: Set<string> } {
  const freeVars = new Set<string>();
  const addFreeVars = (node: CoreExpr, localBound: Set<string>) => {
    const collected = collectFreeVars(node, localBound).freeVars;
    for (const name of collected) {
      freeVars.add(name);
    }
  };
  for (const kase of expr.cases) {
    const caseBound = new Set(bound);
    for (const name of boundNamesInPattern(kase.pattern)) {
      caseBound.add(name);
    }
    if (kase.guard) addFreeVars(kase.guard, caseBound);
    addFreeVars(kase.body, caseBound);
  }
  if (expr.fallback) addFreeVars(expr.fallback, bound);
  return { freeVars };
}

function emitMatchCase(
  kase: CoreMatchCase,
  scrutineeRef: string,
  ctx: EmitContext,
  baseScope: Map<string, VarRef>,
  label: string,
  scrutineeTypeName?: string,
): string[] {
  const caseScope = new Map(baseScope);
  const usedVars = collectUsedVars(kase.body);
  if (kase.guard) {
    const guardUsed = collectUsedVars(kase.guard);
    for (const name of guardUsed) {
      usedVars.add(name);
    }
  }
  const { conditions, bindings } = emitPattern(
    kase.pattern,
    scrutineeRef,
    ctx,
    caseScope,
    usedVars,
    scrutineeTypeName,
  );
  const conditionExpr = conditions.length > 0
    ? conditions.map((cond) => `(${cond})`).join(" and ")
    : "true";
  const guardExpr = kase.guard
    ? emitExprWithScope(kase.guard, ctx, caseScope)
    : undefined;
  const bodyExpr = emitExprWithScope(kase.body, ctx, caseScope);

  const lines: string[] = [];
  lines.push(`if (${conditionExpr}) {`);
  const innerLines: string[] = [];
  innerLines.push(...bindings);
  if (guardExpr) {
    innerLines.push(`if (runtime.expectBool(${guardExpr})) {`);
    innerLines.push(indent(`break :${label} ${bodyExpr};`));
    innerLines.push("}");
  } else {
    innerLines.push(`break :${label} ${bodyExpr};`);
  }
  lines.push(...innerLines.map((line) => indent(line)));
  lines.push("}");
  return lines;
}

interface PatternEmission {
  conditions: string[];
  bindings: string[];
}

function emitPattern(
  pattern: CorePattern,
  valueRef: string,
  ctx: EmitContext,
  scope: Map<string, VarRef>,
  usedVars: Set<string>,
  overrideConstructorTypeName?: string,
): PatternEmission {
  const ref = `(${valueRef})`;
  switch (pattern.kind) {
    case "wildcard":
      return { conditions: [], bindings: [] };
    case "binding": {
      if (!usedVars.has(pattern.name)) {
        return {
          conditions: [],
          bindings: [`_ = ${ref};`],
        };
      }
      const name = bindShadowingLocal(scope, pattern.name, ctx.state);
      return {
        conditions: [],
        bindings: [`const ${name} = ${ref};`],
      };
    }
    case "pinned": {
      const existing = resolveVar(pattern.name, ctx).value;
      return {
        conditions: [`runtime.valueEquals(${ref}, ${existing})`],
        bindings: [],
      };
    }
    case "literal": {
      const literalExpr = emitLiteral({ literal: pattern.literal }, ctx);
      return {
        conditions: [`runtime.valueEquals(${ref}, ${literalExpr})`],
        bindings: [],
      };
    }
    case "tuple": {
      const length = pattern.elements.length;
      const conditions = [
        `runtime.isTuple(${ref}, ${length})`,
      ];
      const bindings: string[] = [];
      for (let index = 0; index < length; index += 1) {
        const nested = emitPattern(
          pattern.elements[index],
          `runtime.tupleGet(${ref}, ${index})`,
          ctx,
          scope,
          usedVars,
          undefined,
        );
        conditions.push(...nested.conditions);
        bindings.push(...nested.bindings);
      }
      return { conditions, bindings };
    }
    case "constructor": {
      const typeName = overrideConstructorTypeName ?? pattern.typeName;
      const conditions = [
        `runtime.isData(${ref}, "${typeName}", "${pattern.constructor}")`,
      ];
      const bindings: string[] = [];
      for (let index = 0; index < pattern.fields.length; index += 1) {
        const nested = emitPattern(
          pattern.fields[index],
          `runtime.dataField(${ref}, ${index})`,
          ctx,
          scope,
          usedVars,
          undefined,
        );
        conditions.push(...nested.conditions);
        bindings.push(...nested.bindings);
      }
      return { conditions, bindings };
    }
    case "all_errors": {
      return {
        conditions: [
          `runtime.isData(${ref}, "${pattern.resultTypeName}", "Err")`,
        ],
        bindings: [],
      };
    }
    default: {
      const _exhaustive: never = pattern;
      void _exhaustive;
      throw new Error(
        `Unsupported pattern kind '${(pattern as CorePattern).kind}'`,
      );
    }
  }
}

function emitExprWithScope(
  expr: CoreExpr,
  ctx: EmitContext,
  scope: Map<string, VarRef>,
): string {
  const previous = ctx.scope;
  ctx.scope = scope;
  try {
    return emitExpr(expr, ctx);
  } finally {
    ctx.scope = previous;
  }
}

function detectHandledResultParams(
  expr: CoreExpr & { kind: "lambda" },
  originalParams: readonly string[],
): number[] {
  const directMatch = resolveMatchInLambda(expr.body, originalParams);
  if (directMatch) {
    const { matchExpr, paramIndex } = directMatch;
    if (paramIndex !== -1) {
      if (!isCarrierType(matchExpr.scrutinee.type)) {
        return [];
      }
      const hasResultPatterns = matchExpr.cases.some((c) =>
        hasResultConstructorPattern(c.pattern)
      );
      if (hasResultPatterns) {
        return [paramIndex];
      }
      const coverage = matchExpr.effectRowCoverage;
      if (coverage?.dischargesResult) {
        return [paramIndex];
      }
    }
  }

  if (expr.body.kind === "match" && expr.body.scrutinee.kind === "tuple") {
    if (!isCarrierType(expr.body.scrutinee.type)) {
      return [];
    }
    const handledIndices: number[] = [];
    for (const matchCase of expr.body.cases) {
      if (matchCase.pattern.kind === "tuple") {
        for (let i = 0; i < matchCase.pattern.elements.length; i += 1) {
          const element = matchCase.pattern.elements[i];
          if (hasResultConstructorPattern(element)) {
            const scrutineeElement = expr.body.scrutinee.elements[i];
            if (scrutineeElement?.kind === "var") {
              const paramIndex = originalParams.indexOf(scrutineeElement.name);
              if (paramIndex !== -1 && !handledIndices.includes(paramIndex)) {
                handledIndices.push(paramIndex);
              }
            }
          }
        }
      }
    }

    if (handledIndices.length > 0) {
      return handledIndices;
    }

    const coverage = expr.body.effectRowCoverage;
    if (coverage?.dischargesResult) {
      for (const element of expr.body.scrutinee.elements) {
        if (element.kind === "var") {
          const paramIndex = originalParams.indexOf(element.name);
          if (paramIndex !== -1) {
            handledIndices.push(paramIndex);
          }
        }
      }
      return handledIndices;
    }
  }

  return [];
}

function resolveMatchInLambda(
  body: CoreExpr,
  params: readonly string[],
): { matchExpr: CoreExpr & { kind: "match" }; paramIndex: number } | null {
  if (body.kind === "match" && body.scrutinee.kind === "var") {
    const paramIndex = params.indexOf(body.scrutinee.name);
    if (paramIndex === -1) return null;
    return { matchExpr: body, paramIndex };
  }
  if (
    body.kind === "call" && body.args.length === 1 &&
    body.args[0].kind === "var" && body.callee.kind === "match"
  ) {
    const paramIndex = params.indexOf(body.args[0].name);
    if (paramIndex === -1) return null;
    return { matchExpr: body.callee, paramIndex };
  }
  return null;
}

function hasResultConstructorPattern(pattern: CorePattern): boolean {
  switch (pattern.kind) {
    case "constructor":
      return isCarrierType(pattern.type);
    case "tuple":
      return pattern.elements.some(hasResultConstructorPattern);
    case "wildcard":
    case "binding":
    case "literal":
    case "all_errors":
    case "pinned":
      return false;
  }
}

function emitPrim(op: CorePrimOp, args: CoreExpr[], ctx: EmitContext): string {
  const emitArg = (index: number) => emitExpr(args[index], ctx);

  switch (op) {
    case "int_add":
      return `runtime.intAdd(${emitArg(0)}, ${emitArg(1)})`;
    case "int_sub":
      return `runtime.intSub(${emitArg(0)}, ${emitArg(1)})`;
    case "int_mul":
      return `runtime.intMul(${emitArg(0)}, ${emitArg(1)})`;
    case "int_div":
      return `runtime.intDiv(${emitArg(0)}, ${emitArg(1)})`;
    case "int_eq":
      return `runtime.intEq(${emitArg(0)}, ${emitArg(1)})`;
    case "int_ne":
      return `runtime.intNe(${emitArg(0)}, ${emitArg(1)})`;
    case "int_lt":
      return `runtime.intLt(${emitArg(0)}, ${emitArg(1)})`;
    case "int_le":
      return `runtime.intLe(${emitArg(0)}, ${emitArg(1)})`;
    case "int_gt":
      return `runtime.intGt(${emitArg(0)}, ${emitArg(1)})`;
    case "int_ge":
      return `runtime.intGe(${emitArg(0)}, ${emitArg(1)})`;
    case "int_cmp":
      return `runtime.intCmp(${emitArg(0)}, ${emitArg(1)})`;
    case "bool_and":
      return `runtime.boolAnd(${emitArg(0)}, ${emitArg(1)})`;
    case "bool_or":
      return `runtime.boolOr(${emitArg(0)}, ${emitArg(1)})`;
    case "bool_not":
      return `runtime.boolNot(${emitArg(0)})`;
    case "char_eq":
      return `runtime.intEq(${emitArg(0)}, ${emitArg(1)})`;
    case "string_length":
      return `runtime.stringLength(${emitArg(0)})`;
    case "string_slice":
      return `runtime.stringSlice(${emitArg(0)}, ${emitArg(1)}, ${emitArg(2)})`;
    case "native_print":
      return `runtime.nativePrintValue(${emitArg(0)})`;
    case "record_get": {
      const target = emitArg(0);
      const field = args[1];
      if (field.kind !== "literal" || field.literal.kind !== "string") {
        throw new Error("record_get expects string literal field");
      }
      const fieldName = JSON.stringify(field.literal.value);
      if (isCarrierType(args[0].type)) {
        return `runtime.recordGetInfectious(${target}, ${fieldName})`;
      }
      return `runtime.recordGet(${target}, ${fieldName})`;
    }
    default:
      throw new Error(`Unsupported primitive op '${op}'`);
  }
}

function resolveVar(name: string, ctx: EmitContext): VarRef {
  const direct = ctx.scope.get(name);
  if (direct) {
    return direct;
  }
  const alias = PRELUDE_OPERATOR_ALIASES.get(name) ??
    PRELUDE_PREFIX_ALIASES.get(name);
  if (alias) {
    const aliasRef = ctx.scope.get(alias);
    if (aliasRef) {
      return aliasRef;
    }
  }
  const runtimeName = makeIdentifierBase(name);
  return { value: `runtime.${runtimeName}`, address: `&runtime.${runtimeName}` };
}


function resolveName(
  scope: Map<string, VarRef>,
  original: string,
  state: NameState,
): string {
  const existing = scope.get(original);
  if (existing) {
    return existing.value;
  }
  return bindLocal(scope, original, state);
}

function bindLocal(
  scope: Map<string, VarRef>,
  original: string,
  state: NameState,
): string {
  const existing = scope.get(original);
  if (existing) return existing.value;
  const sanitized = sanitizeIdentifier(original, state);
  scope.set(original, { value: sanitized, address: `&${sanitized}` });
  return sanitized;
}

function bindShadowingLocal(
  scope: Map<string, VarRef>,
  original: string,
  state: NameState,
): string {
  const sanitized = sanitizeIdentifier(original, state);
  scope.set(original, { value: sanitized, address: `&${sanitized}` });
  return sanitized;
}

function sanitizeIdentifier(name: string, state: NameState): string {
  const base = makeIdentifierBase(name);
  let candidate = base;
  while (RESERVED.has(candidate) || state.used.has(candidate)) {
    candidate = `${base}_${state.counter++}`;
  }
  state.used.add(candidate);
  return candidate;
}

function sanitizeExportName(
  desired: string,
  localName: string,
  state: NameState,
): string {
  if (desired === "_") {
    return "_";
  }
  let candidate = makeIdentifierBase(desired);
  if (candidate === "") {
    candidate = "_";
  }
  if (RESERVED.has(candidate)) {
    candidate = `_${candidate}`;
  }
  if (candidate === localName) {
    return candidate;
  }
  let unique = candidate;
  let counter = 0;
  while (state.used.has(unique)) {
    unique = `${candidate}_${counter++}`;
  }
  state.used.add(unique);
  return unique;
}

function allocateTempName(state: NameState, base: string): string {
  return sanitizeIdentifier(base, state);
}

function allocateLabel(state: NameState): string {
  return allocateTempName(state, "__blk");
}

function makeIdentifierBase(name: string): string {
  const cleaned = name.replace(/[^A-Za-z0-9_]/g, "_");
  if (/^[A-Za-z_]/.test(cleaned)) {
    return cleaned;
  }
  return `_${cleaned || "name"}`;
}

function indent(text: string): string {
  return text.split("\n").map((line) => (line.length > 0 ? `  ${line}` : line))
    .join("\n");
}
