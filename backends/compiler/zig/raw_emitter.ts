import { dirname, extname, relative } from "../../../src/io.ts";
import type {
  CoreExpr,
  CoreLiteral,
  CoreMatchCase,
  CoreModule,
  CoreModuleGraph,
  CorePattern,
  CorePrimOp,
  CoreTypeDeclaration,
} from "../ir/core.ts";
import type { Type } from "../../../src/types.ts";

interface NameState {
  used: Set<string>;
  counter: number;
}

interface VarRef {
  value: string;
  address: string;
}

interface EmitContext {
  state: NameState;
  scope: Map<string, VarRef>;
  options: EmitModuleOptions;
  modulePath: string;
  hoisted: string[];
}

export interface EmitModuleOptions {
  readonly extension?: string;
  readonly baseDir?: string;
}

const RESERVED = new Set<string>([
  "align", "allowzero", "and", "anyframe", "anytype", "asm", "async",
  "await", "break", "catch", "comptime", "const", "continue", "defer",
  "else", "enum", "errdefer", "error", "export", "extern", "false",
  "for", "if", "inline", "linksection", "noalias", "noinline", "nosuspend",
  "opaque", "or", "orelse", "packed", "pub", "resume", "return", "struct",
  "suspend", "switch", "test", "threadlocal", "true", "try", "union",
  "unreachable", "usingnamespace", "var", "volatile", "while", "_",
]);

// Map __op_* calls to native Zig operators
const RAW_OPERATOR_MAP = new Map<string, string>([
  ["__op_+", "+"],
  ["__op_-", "-"],
  ["__op_*", "*"],
  ["__op_/", "/"],
  ["__op_%", "%"],
  ["__op_==", "=="],
  ["__op_!=", "!="],
  ["__op_<", "<"],
  ["__op_>", ">"],
  ["__op_<=", "<="],
  ["__op_>=", ">="],
  ["__op_&&", "and"],
  ["__op_||", "or"],
]);

// Zig primitive types that should not be imported (they're built-in)
const ZIG_PRIMITIVES = new Set<string>([
  // Signed integers
  "i8", "i16", "i32", "i64", "i128", "isize",
  // Unsigned integers
  "u8", "u16", "u32", "u64", "u128", "usize",
  // Floating point
  "f16", "f32", "f64", "f128",
  // Special types
  "bool", "void", "noreturn", "anyerror", "comptime_int", "comptime_float",
  // C interop types
  "c_short", "c_ushort", "c_int", "c_uint", "c_long", "c_ulong",
  "c_longlong", "c_ulonglong", "c_char",
]);

/**
 * Raw mode emitter - outputs direct Zig code without runtime wrapper.
 * Used for build.wm -> build.zig and other "zig mode" Workman files.
 */
export function emitRawModule(
  module: CoreModule,
  _graph: CoreModuleGraph,
  options: EmitModuleOptions = {},
): string {
  const extension = options.extension ?? ".zig";

  const state: NameState = { used: new Set(), counter: 0 };
  const scope = new Map<string, VarRef>();
  const ctx: EmitContext = {
    state,
    scope,
    options: { ...options, extension },
    modulePath: module.path,
    hoisted: [],
  };

  preallocateNames(module, ctx);

  const lines: string[] = [];
  lines.push("// Generated by Workman compiler (Raw Zig mode)");

  // Emit imports (skip Zig primitives - they're built-in)
  for (const imp of module.imports) {
    const relPath = computeRelativePath(module.path, imp.source, extension, options.baseDir);
    for (const spec of imp.specifiers) {
      if (spec.kind === "value") {
        // Skip importing Zig primitive types - they're built-in
        if (ZIG_PRIMITIVES.has(spec.imported)) {
          continue;
        }
        const ref = resolveName(ctx.scope, spec.local, ctx.state);
        lines.push(`const ${ref} = @import("${relPath}").${sanitizeIdentifier(spec.imported, ctx.state)};`);
      }
    }
  }

  // Collect exports
  const exportSet = new Set<string>();
  for (const exp of module.exports) {
    if (exp.kind === "value") {
      exportSet.add(exp.local);
    }
  }

  // Emit type declarations
  for (const decl of module.typeDeclarations) {
    lines.push(...emitTypeDeclaration(decl, ctx));
  }

  // Emit value bindings
  for (const binding of module.values) {
    const bindingRef = resolveName(ctx.scope, binding.name, ctx.state);
    // main must always be pub for Zig's entry point
    const isExported = exportSet.has(binding.name) || binding.name === "main";
    
    // For lambdas, emit as named functions
    if (binding.value.kind === "lambda") {
      const fnCode = emitNamedLambda(binding.value, bindingRef, ctx);
      lines.push(`${isExported ? "pub " : ""}${fnCode}`);
    } else {
      const expr = emitExpr(binding.value, ctx);
      lines.push(`${isExported ? "pub " : ""}const ${bindingRef} = ${expr};`);
    }
  }

  if (ctx.hoisted.length > 0) {
    lines.unshift(...ctx.hoisted);
  }

  return `${lines.join("\n")}\n`;
}

function preallocateNames(module: CoreModule, ctx: EmitContext): void {
  for (const binding of module.values) {
    bindLocal(ctx.scope, binding.name, ctx.state);
  }
}

function computeRelativePath(
  fromPath: string,
  toPath: string,
  extension: string,
  baseDir?: string,
): string {
  const fromDir = dirname(fromPath);
  let rel = relative(fromDir, toPath);
  const ext = extname(rel);
  if (ext) {
    rel = rel.slice(0, -ext.length) + extension;
  }
  if (!rel.startsWith(".")) {
    rel = "./" + rel;
  }
  return rel.replace(/\\/g, "/");
}

function sanitizeIdentifier(name: string, state: NameState): string {
  if (RESERVED.has(name)) {
    return `@"${name}"`;
  }
  if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name)) {
    return name;
  }
  return `@"${name}"`;
}

function allocateTempName(state: NameState, prefix: string): string {
  let name: string;
  do {
    name = `${prefix}_${state.counter++}`;
  } while (state.used.has(name));
  state.used.add(name);
  return name;
}

function bindLocal(scope: Map<string, VarRef>, name: string, state: NameState): VarRef {
  const sanitized = sanitizeIdentifier(name, state);
  let finalName = sanitized;
  if (state.used.has(sanitized) || RESERVED.has(name)) {
    finalName = allocateTempName(state, sanitized.replace(/^@"|"$/g, ""));
  }
  state.used.add(finalName);
  const ref: VarRef = { value: finalName, address: `&${finalName}` };
  scope.set(name, ref);
  return ref;
}

function resolveName(scope: Map<string, VarRef>, name: string, state: NameState): string {
  const existing = scope.get(name);
  if (existing) {
    return existing.value;
  }
  return sanitizeIdentifier(name, state);
}

function emitTypeDeclaration(decl: CoreTypeDeclaration, ctx: EmitContext): string[] {
  const lines: string[] = [];
  // For opaque types, just emit a type alias placeholder
  if (decl.constructors.length === 0) {
    // Opaque type - these map directly to Zig types
    // Don't emit anything - they're built-in Zig types
    return lines;
  }
  // For ADTs, emit as tagged union
  // TODO: implement proper ADT emission
  return lines;
}

function emitExpr(expr: CoreExpr, ctx: EmitContext): string {
  switch (expr.kind) {
    case "literal":
      return emitLiteral(expr.literal);
    case "var":
      return resolveName(ctx.scope, expr.name, ctx.state);
    case "lambda":
      return emitLambda(expr, ctx);
    case "call":
      return emitCall(expr, ctx);
    case "let":
      return emitLet(expr, ctx);
    case "let_rec":
      return emitLetRec(expr, ctx);
    case "match":
      return emitMatch(expr, ctx);
    case "if":
      return emitIf(expr, ctx);
    case "prim":
      return emitPrimOp(expr.op, expr.args, ctx);
    case "record":
      return emitRecord(expr, ctx);
    case "tuple_get":
      return `${emitExpr(expr.target, ctx)}[${expr.index}]`;
    case "data":
      return emitData(expr, ctx);
    case "tuple":
      return emitTuple(expr, ctx);
    default:
      throw new Error(`Unsupported expression kind '${(expr as CoreExpr).kind}' in raw mode`);
  }
}

function emitLiteral(lit: CoreLiteral): string {
  switch (lit.kind) {
    case "int":
      return String(lit.value);
    case "bool":
      return lit.value ? "true" : "false";
    case "char":
      return `'\\x${lit.value.toString(16).padStart(2, "0")}'`;
    case "string":
      return `"${lit.value.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n")}"`;
    case "unit":
      return "{}";
  }
}

function emitRecord(
  expr: CoreExpr & { kind: "record" },
  ctx: EmitContext,
): string {
  if (expr.fields.length === 0) {
    return ".{}";
  }
  const fields = expr.fields.map((field) => {
    const value = emitExpr(field.value, ctx);
    return `.${sanitizeIdentifier(field.name, ctx.state)} = ${value}`;
  }).join(", ");
  return `.{ ${fields} }`;
}

function emitNamedLambda(
  expr: CoreExpr & { kind: "lambda" },
  name: string,
  ctx: EmitContext,
): string {
  // Extract parameter types from the lambda's function type
  const paramTypes = getParamTypes(expr.type, expr.params.length);
  const params = expr.params.map((p, i) => {
    const pname = sanitizeIdentifier(p, ctx.state);
    const ptype = paramTypes[i] ? emitType(paramTypes[i]) : "anytype";
    return `${pname}: ${ptype}`;
  }).join(", ");
  
  const scope = new Map(ctx.scope);
  for (const p of expr.params) {
    bindLocal(scope, p, ctx.state);
  }
  
  const innerCtx = { ...ctx, scope };
  const body = emitExpr(expr.body, innerCtx);
  
  // Get return type from the lambda's type annotation
  const returnType = emitType(expr.type);
  
  return `fn ${name}(${params}) ${returnType} { return ${body}; }`;
}

function emitLambda(
  expr: CoreExpr & { kind: "lambda" },
  ctx: EmitContext,
): string {
  const fnName = allocateTempName(ctx.state, "__fn");
  return emitNamedLambda(expr, fnName, ctx);
}

function emitCall(
  expr: CoreExpr & { kind: "call" },
  ctx: EmitContext,
): string {
  // Check if this is an operator call (__op_+, __op_-, etc.)
  if (expr.callee.kind === "var" && RAW_OPERATOR_MAP.has(expr.callee.name)) {
    const op = RAW_OPERATOR_MAP.get(expr.callee.name)!;
    if (expr.args.length === 2) {
      const left = emitExpr(expr.args[0], ctx);
      const right = emitExpr(expr.args[1], ctx);
      return `(${left} ${op} ${right})`;
    }
  }
  const fn = emitExpr(expr.callee, ctx);
  const args = expr.args.map((arg) => emitExpr(arg, ctx)).join(", ");
  return `${fn}(${args})`;
}

function emitLet(
  expr: CoreExpr & { kind: "let" },
  ctx: EmitContext,
): string {
  const scope = new Map(ctx.scope);
  const value = emitExpr(expr.binding.value, ctx);
  const innerCtx = { ...ctx, scope };
  const body = emitExpr(expr.body, innerCtx);
  const label = allocateTempName(ctx.state, "blk");
  
  // For discarded statement results (__stmt_*), use _ to avoid unused variable warning
  if (expr.binding.name.startsWith("__stmt")) {
    return `${label}: { _ = ${value}; break :${label} ${body}; }`;
  }
  
  const ref = bindLocal(scope, expr.binding.name, ctx.state);
  return `${label}: { const ${ref.value} = ${value}; break :${label} ${body}; }`;
}

function emitMatch(
  expr: CoreExpr & { kind: "match" },
  ctx: EmitContext,
): string {
  const scrutinee = emitExpr(expr.scrutinee, ctx);
  const cases = expr.cases.map((c) => emitMatchCase(c, scrutinee, ctx)).join(", ");
  return `switch (${scrutinee}) { ${cases} }`;
}

function emitMatchCase(
  matchCase: CoreMatchCase,
  scrutinee: string,
  ctx: EmitContext,
): string {
  const pattern = emitPattern(matchCase.pattern, ctx);
  const scope = new Map(ctx.scope);
  bindPatternVars(matchCase.pattern, scope, ctx.state);
  const innerCtx = { ...ctx, scope };
  const body = emitExpr(matchCase.body, innerCtx);
  return `${pattern} => ${body}`;
}

function emitPattern(pattern: CorePattern, ctx: EmitContext): string {
  switch (pattern.kind) {
    case "wildcard":
      return "_";
    case "binding":
      return sanitizeIdentifier(pattern.name, ctx.state);
    case "literal":
      return emitLiteral(pattern.literal);
    case "constructor":
      if (pattern.fields.length === 0) {
        return `.${pattern.constructor}`;
      }
      const args = pattern.fields.map((a) => emitPattern(a, ctx)).join(", ");
      return `.${pattern.constructor} => |${args}|`;
    case "tuple":
      const elements = pattern.elements.map((e) => emitPattern(e, ctx)).join(", ");
      return `.{ ${elements} }`;
    case "pinned":
      return sanitizeIdentifier(pattern.name, ctx.state);
    case "all_errors":
      return "_";
  }
}

function bindPatternVars(
  pattern: CorePattern,
  scope: Map<string, VarRef>,
  state: NameState,
): void {
  switch (pattern.kind) {
    case "binding":
      bindLocal(scope, pattern.name, state);
      break;
    case "constructor":
      for (const field of pattern.fields) {
        bindPatternVars(field, scope, state);
      }
      break;
    case "tuple":
      for (const el of pattern.elements) {
        bindPatternVars(el, scope, state);
      }
      break;
    case "wildcard":
    case "literal":
    case "pinned":
    case "all_errors":
      break;
  }
}

function emitIf(
  expr: CoreExpr & { kind: "if" },
  ctx: EmitContext,
): string {
  const cond = emitExpr(expr.condition, ctx);
  const thenBranch = emitExpr(expr.thenBranch, ctx);
  const elseBranch = emitExpr(expr.elseBranch, ctx);
  return `if (${cond}) ${thenBranch} else ${elseBranch}`;
}

function emitPrimOp(op: CorePrimOp, args: readonly CoreExpr[], ctx: EmitContext): string {
  const emittedArgs = [...args].map((a) => emitExpr(a, ctx));
  
  switch (op) {
    case "int_add":
      return `(${emittedArgs[0]} + ${emittedArgs[1]})`;
    case "int_sub":
      return `(${emittedArgs[0]} - ${emittedArgs[1]})`;
    case "int_mul":
      return `(${emittedArgs[0]} * ${emittedArgs[1]})`;
    case "int_div":
      return `@divTrunc(${emittedArgs[0]}, ${emittedArgs[1]})`;
    case "int_eq":
      return `(${emittedArgs[0]} == ${emittedArgs[1]})`;
    case "int_ne":
      return `(${emittedArgs[0]} != ${emittedArgs[1]})`;
    case "int_lt":
      return `(${emittedArgs[0]} < ${emittedArgs[1]})`;
    case "int_le":
      return `(${emittedArgs[0]} <= ${emittedArgs[1]})`;
    case "int_gt":
      return `(${emittedArgs[0]} > ${emittedArgs[1]})`;
    case "int_ge":
      return `(${emittedArgs[0]} >= ${emittedArgs[1]})`;
    case "int_cmp":
      return `std.math.order(${emittedArgs[0]}, ${emittedArgs[1]})`;
    case "bool_and":
      return `(${emittedArgs[0]} and ${emittedArgs[1]})`;
    case "bool_or":
      return `(${emittedArgs[0]} or ${emittedArgs[1]})`;
    case "bool_not":
      return `(!${emittedArgs[0]})`;
    case "char_eq":
      return `(${emittedArgs[0]} == ${emittedArgs[1]})`;
    case "string_length":
      return `${emittedArgs[0]}.len`;
    case "string_slice":
      return `${emittedArgs[0]}[${emittedArgs[1]}..${emittedArgs[2]}]`;
    case "record_get":
      return `${emittedArgs[0]}.${emittedArgs[1]}`;
    case "native_print":
      return `std.debug.print("{any}", .{${emittedArgs[0]}})`;
  }
}

function emitData(
  expr: CoreExpr & { kind: "data" },
  ctx: EmitContext,
): string {
  if (expr.fields.length === 0) {
    return `.${expr.constructor}`;
  }
  const args = expr.fields.map((a) => emitExpr(a, ctx)).join(", ");
  return `.{ .${expr.constructor} = .{ ${args} } }`;
}

function emitTuple(
  expr: CoreExpr & { kind: "tuple" },
  ctx: EmitContext,
): string {
  const elements = expr.elements.map((e) => emitExpr(e, ctx)).join(", ");
  return `.{ ${elements} }`;
}

function emitLetRec(
  expr: CoreExpr & { kind: "let_rec" },
  ctx: EmitContext,
): string {
  const scope = new Map(ctx.scope);
  const bindings: string[] = [];
  for (const binding of expr.bindings) {
    const ref = bindLocal(scope, binding.name, ctx.state);
    bindings.push(`const ${ref.value} = ${emitExpr(binding.value, { ...ctx, scope })};`);
  }
  const innerCtx = { ...ctx, scope };
  const body = emitExpr(expr.body, innerCtx);
  const label = allocateTempName(ctx.state, "blk");
  return `${label}: { ${bindings.join(" ")} break :${label} ${body}; }`;
}

function emitType(type: Type): string {
  switch (type.kind) {
    case "int":
      return "i32"; // Default to i32 for now
    case "bool":
      return "bool";
    case "char":
      return "u8";
    case "string":
      return "[]const u8";
    case "unit":
      return "void";
    case "func":
      // For function types, we need the return type
      return emitType(getReturnType(type));
    case "constructor":
      // Opaque types like i32, u64 etc. - emit directly
      return type.name;
    case "tuple":
      const elements = type.elements.map(emitType).join(", ");
      return `struct { ${elements} }`;
    case "record":
      const fields = Array.from(type.fields.entries())
        .map(([name, t]) => `${name}: ${emitType(t)}`)
        .join(", ");
      return `struct { ${fields} }`;
    case "var":
      return "anytype";
    default:
      return "anytype";
  }
}

function getReturnType(type: Type): Type {
  if (type.kind === "func") {
    return getReturnType(type.to);
  }
  return type;
}

function getParamTypes(type: Type, count: number): Type[] {
  const types: Type[] = [];
  let current = type;
  for (let i = 0; i < count && current.kind === "func"; i++) {
    types.push(current.from);
    current = current.to;
  }
  return types;
}
