import { dirname, extname, relative } from "../../../src/io.ts";
import type {
  CoreExpr,
  CoreLiteral,
  CoreMatchCase,
  CoreModule,
  CoreModuleGraph,
  CorePattern,
  CorePrimOp,
  CoreTypeDeclaration,
} from "../ir/core.ts";
import type { Type } from "../../../src/types.ts";

interface NameState {
  used: Set<string>;
  counter: number;
}

function getOrCreateCImportBinding(ctx: EmitContext, source: string): string {
  const existing = ctx.cImports.get(source);
  if (existing) {
    return existing;
  }
  const binding = allocateTempName(ctx.state, "c_import");
  ctx.cImports.set(source, binding);
  ctx.hoisted.push(`const ${binding} = @cImport(@cInclude("${source}"));`);
  return binding;
}

interface VarRef {
  value: string;
  address: string;
}

interface EmitContext {
  state: NameState;
  scope: Map<string, VarRef>;
  typeBindings: Map<string, string>;
  captureInfo?: Map<string, string[]>;
  options: EmitModuleOptions;
  modulePath: string;
  hoisted: string[];
  /** Collected .wm source file paths referenced in string literals */
  wmSourcePaths: Set<string>;
  /** Module-level names (imports and top-level bindings) - these don't need to be captured */
  moduleNames: Set<string>;
  /** Map of function names to their captured variables (for let_rec) */
  capturedVarsMap: Map<string, string[]>;
  /** Cached c header imports so we only @cImport each header once */
  cImports: Map<string, string>;
}

export interface EmitModuleOptions {
  readonly extension?: string;
  readonly baseDir?: string;
  /** If true, rewrite .wm paths to .zig in string literals */
  readonly rewriteWmPaths?: boolean;
}

export interface EmitRawResult {
  readonly code: string;
  /** .wm source file paths found in string literals (before rewriting) */
  readonly wmSourcePaths: readonly string[];
}

const RESERVED = new Set<string>([
  "align", "allowzero", "and", "anyframe", "anytype", "asm", "async",
  "await", "break", "catch", "comptime", "const", "continue", "defer",
  "else", "enum", "errdefer", "error", "export", "extern", "false",
  "for", "if", "inline", "linksection", "noalias", "noinline", "nosuspend",
  "opaque", "or", "orelse", "packed", "pub", "resume", "return", "struct",
  "suspend", "switch", "test", "threadlocal", "true", "try", "union",
  "unreachable", "usingnamespace", "var", "volatile", "while", "_",
]);

// Map __op_* calls to native Zig operators
const RAW_OPERATOR_MAP = new Map<string, string>([
  ["__op_+", "+"],
  ["__op_-", "-"],
  ["__op_*", "*"],
  ["__op_/", "/"],
  ["__op_%", "%"],
  ["__op_==", "=="],
  ["__op_!=", "!="],
  ["__op_<", "<"],
  ["__op_>", ">"],
  ["__op_<=", "<="],
  ["__op_>=", ">="],
  ["__op_&&", "and"],
  ["__op_||", "or"],
]);

const RAW_OMITTED_BINDINGS = new Set<string>([
  "zig_optional_is_non_null",
  "zig_optional_unwrap",
  "zig_optional_unwrap_or",
  "zig_alloc_struct",
  "zig_alloc_struct_uninit",
  "zig_alloc_struct_init",
  "zig_alloc_slice",
  "zig_free",
  "zig_free_slice",
]);

const RAW_STD_ZIG_OPTION_HELPERS = new Set<string>([
  "isSome",
  "isNone",
  "unwrap",
  "unwrapOr",
  "expect",
]);

// Zig primitive types that should not be imported (they're built-in)
const ZIG_PRIMITIVES = new Set<string>([
  // Signed integers
  "i8", "i16", "i32", "i64", "i128", "isize",
  // Unsigned integers
  "u8", "u16", "u32", "u64", "u128", "usize",
  // Floating point
  "f16", "f32", "f64", "f128",
  // Special types
  "bool", "void", "noreturn", "anyerror", "comptime_int", "comptime_float",
  // C interop types
  "c_short", "c_ushort", "c_int", "c_uint", "c_long", "c_ulong",
  "c_longlong", "c_ulonglong", "c_char",
]);

/**
 * Raw mode emitter - outputs direct Zig code without runtime wrapper.
 * Used for build.wm -> build.zig and other "zig mode" Workman files.
 */
export function emitRawModule(
  module: CoreModule,
  _graph: CoreModuleGraph,
  options: EmitModuleOptions = {},
): EmitRawResult {
  const extension = options.extension ?? ".zig";
  const isStdZigOption = normalizeSlashes(module.path)
    .toLowerCase()
    .endsWith("/std/zig/option.wm");

  const state: NameState = { used: new Set(), counter: 0 };
  const scope = new Map<string, VarRef>();
  
  // Collect module-level names (imports and top-level bindings)
  const moduleNames = new Set<string>();
  for (const imp of module.imports) {
    for (const spec of imp.specifiers) {
      if (spec.kind === "value") {
        moduleNames.add(spec.local);
      }
    }
  }
  for (const binding of module.values) {
    moduleNames.add(binding.name);
  }
  
  const ctx: EmitContext = {
    state,
    scope,
    typeBindings: new Map(),
    options: { ...options, extension },
    modulePath: module.path,
    hoisted: [],
    wmSourcePaths: new Set(),
    moduleNames,
    capturedVarsMap: new Map(),
    cImports: new Map(),
  };

  preallocateNames(module, ctx);

  const lines: string[] = [];
  lines.push("// Generated by Workman compiler (Raw Zig mode)");

  // Emit imports (skip Zig primitives - they're built-in)
  for (const imp of module.imports) {
    // Check if this is a C header import
    const isCHeader = imp.source.endsWith(".h");
    
    for (const spec of imp.specifiers) {
      if (spec.kind === "value") {
        // Skip importing Zig primitive types - they're built-in
        if (ZIG_PRIMITIVES.has(spec.imported)) {
          continue;
        }
        const ref = resolveName(ctx.scope, spec.local, ctx.state);
        ctx.typeBindings.set(spec.local, ref);
        
        if (isCHeader) {
          const cImportBinding = getOrCreateCImportBinding(ctx, imp.source);
          lines.push(`const ${ref} = ${cImportBinding}.${sanitizeIdentifier(spec.imported, ctx.state)};`);
        } else {
          const relPath = computeRelativePath(module.path, imp.source, extension, options.baseDir);
          lines.push(`const ${ref} = @import("${relPath}").${sanitizeIdentifier(spec.imported, ctx.state)};`);
        }
      }
    }
  }

  // Collect exports
  const exportSet = new Set<string>();
  for (const exp of module.exports) {
    if (exp.kind === "value") {
      exportSet.add(exp.local);
    }
  }

  // Emit type declarations
  for (const decl of module.typeDeclarations) {
    lines.push(...emitTypeDeclaration(decl, ctx));
  }

  // Emit value bindings
  for (const binding of module.values) {
    if (RAW_OMITTED_BINDINGS.has(binding.name)) {
      continue;
    }
    const bindingRef = resolveName(ctx.scope, binding.name, ctx.state);
    // main must always be pub for Zig's entry point
    const isExported = exportSet.has(binding.name) || binding.name === "main";
    
    // For lambdas, emit as named functions
    if (binding.value.kind === "lambda") {
      if (isStdZigOption && RAW_STD_ZIG_OPTION_HELPERS.has(binding.name)) {
        lines.push(emitRawZigOptionHelper(binding.name, bindingRef, isExported));
      } else {
        const fnCode = emitNamedLambda(binding.value, bindingRef, ctx);
        lines.push(`${isExported ? "pub " : ""}${fnCode}`);
      }
    } else {
      const expr = emitExpr(binding.value, ctx);
      lines.push(`${isExported ? "pub " : ""}const ${bindingRef} = ${expr};`);
    }
  }

  if (ctx.hoisted.length > 0) {
    lines.unshift(...ctx.hoisted);
  }

  return {
    code: `${lines.join("\n")}\n`,
    wmSourcePaths: Array.from(ctx.wmSourcePaths),
  };
}

function emitRawZigOptionHelper(
  name: string,
  ref: string,
  isExported: boolean,
): string {
  const prefix = isExported ? "pub " : "";
  switch (name) {
    case "isSome":
      return `${prefix}fn ${ref}(value: anytype) bool { return (value != null); }`;
    case "isNone":
      return `${prefix}fn ${ref}(value: anytype) bool { return (value == null); }`;
    case "unwrap":
      return `${prefix}fn ${ref}(value: anytype) @TypeOf((value).?) { return (value).?; }`;
    case "unwrapOr":
      return `${prefix}fn ${ref}(value: anytype, defaultValue: anytype) @TypeOf((value) orelse defaultValue) { return (value) orelse defaultValue; }`;
    case "expect":
      return `${prefix}fn ${ref}(value: anytype, message: []const u8) @TypeOf((value).?) { if (value != null) return (value).?; zig.debug.panic("{s}", .{message}); }`;
    default:
      return `${prefix}fn ${ref}() void { }`;
  }
}

function preallocateNames(module: CoreModule, ctx: EmitContext): void {
  for (const binding of module.values) {
    bindLocal(ctx.scope, binding.name, ctx.state);
  }
}

function computeRelativePath(
  fromPath: string,
  toPath: string,
  extension: string,
  baseDir?: string,
): string {
  const fromDir = baseDir ?? dirname(fromPath);
  let rel = relative(fromDir, toPath);
  const ext = extname(rel);
  if (ext) {
    rel = rel.slice(0, -ext.length) + extension;
  }
  if (!rel.startsWith(".")) {
    rel = "./" + rel;
  }
  return rel.replace(/\\/g, "/");
}

function normalizeSlashes(path: string): string {
  return path.replace(/\\/g, "/");
}

function sanitizeIdentifier(name: string, state: NameState): string {
  if (RESERVED.has(name)) {
    return `@"${name}"`;
  }
  if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name)) {
    return name;
  }
  return `@"${name}"`;
}

function isIntentionallyUnusedName(name: string): boolean {
  return name.length > 1 && name.startsWith("_") && !name.startsWith("__");
}

function allocateTempName(state: NameState, prefix: string): string {
  let name: string;
  do {
    name = `${prefix}_${state.counter++}`;
  } while (state.used.has(name));
  state.used.add(name);
  return name;
}

function bindLocal(scope: Map<string, VarRef>, name: string, state: NameState): VarRef {
  const sanitized = sanitizeIdentifier(name, state);
  let finalName = sanitized;
  if (state.used.has(sanitized) || RESERVED.has(name)) {
    finalName = allocateTempName(state, sanitized.replace(/^@"|"$/g, ""));
  }
  state.used.add(finalName);
  const ref: VarRef = { value: finalName, address: `&${finalName}` };
  scope.set(name, ref);
  return ref;
}

function resolveName(scope: Map<string, VarRef>, name: string, state: NameState): string {
  const existing = scope.get(name);
  if (existing) {
    return existing.value;
  }
  return sanitizeIdentifier(name, state);
}

function emitTypeDeclaration(decl: CoreTypeDeclaration, ctx: EmitContext): string[] {
  const lines: string[] = [];
  // For opaque types, just emit a type alias placeholder
  if (decl.constructors.length === 0) {
    // Opaque type - these map directly to Zig types
    // Don't emit anything - they're built-in Zig types
    return lines;
  }
  // For ADTs, emit as tagged union
  // TODO: implement proper ADT emission
  return lines;
}

function emitExpr(expr: CoreExpr, ctx: EmitContext): string {
  switch (expr.kind) {
    case "literal":
      return emitLiteral(expr.literal, ctx);
    case "var":
      if (expr.name === "null" && !ctx.scope.has("null")) {
        return "null";
      }
      return resolveName(ctx.scope, expr.name, ctx.state);
    case "lambda":
      return emitLambda(expr, ctx);
    case "call":
      return emitCall(expr, ctx);
    case "let":
      return emitLet(expr, ctx);
    case "let_rec":
      return emitLetRec(expr, ctx);
    case "match":
      return emitMatch(expr, ctx);
    case "if":
      return emitIf(expr, ctx);
    case "prim":
      return emitPrimOp(expr.op, expr.args, ctx);
    case "record":
      return emitRecord(expr, ctx);
    case "tuple_get":
      return `${emitExpr(expr.target, ctx)}[${expr.index}]`;
    case "data":
      return emitData(expr, ctx);
    case "tuple":
      return emitTuple(expr, ctx);
    case "enum_literal":
      return `.${expr.name}`;
    default:
      throw new Error(`Unsupported expression kind '${(expr as CoreExpr).kind}' in raw mode`);
  }
}

function emitLiteral(lit: CoreLiteral, ctx: EmitContext): string {
  switch (lit.kind) {
    case "int":
      return String(lit.value);
    case "bool":
      return lit.value ? "true" : "false";
    case "char":
      return `'\\x${lit.value.toString(16).padStart(2, "0")}'`;
    case "string": {
      let value = lit.value;
      // Track and optionally rewrite .wm paths to .zig
      if (value.endsWith(".wm")) {
        ctx.wmSourcePaths.add(value);
        if (ctx.options.rewriteWmPaths !== false) {
          value = value.slice(0, -3) + ".zig";
        }
      }
      return `"${value.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n")}"`;
    }
    case "unit":
      return "{}";
  }
}

function emitRecord(
  expr: CoreExpr & { kind: "record" },
  ctx: EmitContext,
): string {
  const fields = expr.fields.map((field) => {
    const value = emitExpr(field.value, ctx);
    return `.${sanitizeIdentifier(field.name, ctx.state)} = ${value}`;
  }).join(", ");
  const literal = expr.fields.length === 0 ? ".{}" : `.{ ${fields} }`;
  const recordTypeRef = resolveRecordTypeReference(expr.type, ctx);
  if (recordTypeRef) {
    if (expr.fields.length === 0) {
      return `${recordTypeRef}{}`;
    }
    return `${recordTypeRef}{ ${fields} }`;
  }
  return literal;
}

function emitNamedLambda(
  expr: CoreExpr & { kind: "lambda" },
  name: string,
  ctx: EmitContext,
): string {
  // Extract parameter types from the lambda's function type
  const paramTypes = getParamTypes(expr.type, expr.params.length);
  const params = expr.params.map((p, i) => {
    const pname = sanitizeIdentifier(p, ctx.state);
    const ptype = paramTypes[i] ? emitType(paramTypes[i]) : "anytype";
    return `${pname}: ${ptype}`;
  }).join(", ");
  
  const scope = new Map(ctx.scope);
  for (const p of expr.params) {
    bindLocal(scope, p, ctx.state);
  }
  
  const innerCtx = { ...ctx, scope };
  const body = emitExpr(expr.body, innerCtx);
  
  // Get return type from the lambda's type annotation
  const returnType = emitType(expr.type);
  
  return `fn ${name}(${params}) ${returnType} { return ${body}; }`;
}

function emitLambda(
  expr: CoreExpr & { kind: "lambda" },
  ctx: EmitContext,
): string {
  const fnName = allocateTempName(ctx.state, "__fn");
  return emitNamedLambda(expr, fnName, ctx);
}

function emitCall(
  expr: CoreExpr & { kind: "call" },
  ctx: EmitContext,
): string {
  // Check if this is an operator call (__op_+, __op_-, etc.)
  if (expr.callee.kind === "var" && RAW_OPERATOR_MAP.has(expr.callee.name)) {
    const op = RAW_OPERATOR_MAP.get(expr.callee.name)!;
    if (expr.args.length === 2) {
      const left = emitExpr(expr.args[0], ctx);
      const right = emitExpr(expr.args[1], ctx);
      return `(${left} ${op} ${right})`;
    }
  }

  if (expr.callee.kind === "var") {
    if (expr.callee.name === "zig_alloc_struct" && expr.args.length === 1) {
      const typeExpr = emitExpr(expr.args[0], ctx);
      return emitRawAllocStruct(typeExpr, ctx, "allocStruct");
    }
    if (expr.callee.name === "zig_alloc_struct_uninit" && expr.args.length === 1) {
      const typeExpr = emitExpr(expr.args[0], ctx);
      return `@import("std").heap.page_allocator.create(${typeExpr}) catch @panic("allocStructUninit failed")`;
    }
    if (expr.callee.name === "zig_alloc_struct_init" && expr.args.length === 2) {
      const typeExpr = emitExpr(expr.args[0], ctx);
      const valueExpr = emitExpr(expr.args[1], ctx);
      return emitRawAllocStruct(typeExpr, ctx, "allocStructInit", valueExpr);
    }
    if (expr.callee.name === "zig_alloc_slice" && expr.args.length === 2) {
      const typeExpr = emitExpr(expr.args[0], ctx);
      const lenExpr = emitExpr(expr.args[1], ctx);
      return emitRawAllocSlice(typeExpr, lenExpr, ctx);
    }
    if (expr.callee.name === "zig_free" && expr.args.length === 1) {
      const ptrExpr = emitExpr(expr.args[0], ctx);
      return `@import("std").heap.page_allocator.destroy(${ptrExpr})`;
    }
    if (expr.callee.name === "zig_free_slice" && expr.args.length === 1) {
      const sliceExpr = emitExpr(expr.args[0], ctx);
      return `@import("std").heap.page_allocator.free(${sliceExpr}.ptr[0..${sliceExpr}.len])`;
    }
    if (expr.callee.name === "zig_optional_is_non_null" && expr.args.length === 1) {
      const value = emitExpr(expr.args[0], ctx);
      return `(${value} != null)`;
    }
    if (expr.callee.name === "zig_optional_unwrap" && expr.args.length === 1) {
      const value = emitExpr(expr.args[0], ctx);
      return `(${value}).?`;
    }
    if (expr.callee.name === "zig_optional_unwrap_or" && expr.args.length === 2) {
      const value = emitExpr(expr.args[0], ctx);
      const fallback = emitExpr(expr.args[1], ctx);
      return `(${value} orelse ${fallback})`;
    }
  }
  
  // Handle zigImport("module") -> @import("module")
  if (expr.callee.kind === "var" && expr.callee.name === "zigImport") {
    if (expr.args.length === 1 && expr.args[0].kind === "literal" && expr.args[0].literal.kind === "string") {
      const moduleName = expr.args[0].literal.value;
      return `@import("${moduleName}")`;
    }
  }
  
  // Check if this is a call to a function with captured vars
  if (expr.callee.kind === "var") {
    const captureMap = ctx.captureInfo ?? ctx.capturedVarsMap;
    const captures = captureMap.get(expr.callee.name);
    if (captures && captures.length > 0) {
      const fn = resolveName(ctx.scope, expr.callee.name, ctx.state);
      const args = expr.args.map((arg) => emitExpr(arg, ctx));
      // Add captured vars as extra args
      for (const v of captures) {
        args.push(resolveName(ctx.scope, v, ctx.state));
      }
      return `${fn}(${args.join(", ")})`;
    }
  }
  
  const fn = emitExpr(expr.callee, ctx);
  const args = expr.args.map((arg) => emitExpr(arg, ctx)).join(", ");
  return `${fn}(${args})`;
}

function emitRawAllocStruct(
  typeExpr: string,
  ctx: EmitContext,
  label: string,
  initExpr?: string,
): string {
  const ptrName = allocateTempName(ctx.state, "alloc_ptr");
  const blockName = allocateTempName(ctx.state, "alloc_blk");
  const stdImport = `@import("std")`;
  const initLine = initExpr
    ? `${ptrName}.* = ${initExpr};`
    : `${ptrName}.* = ${stdImport}.mem.zeroes(${typeExpr});`;
  return `${blockName}: { const ${ptrName} = ${stdImport}.heap.page_allocator.create(${typeExpr}) catch @panic("${label} failed"); ${initLine} break :${blockName} ${ptrName}; }`;
}

function emitRawAllocSlice(
  typeExpr: string,
  lenExpr: string,
  ctx: EmitContext,
): string {
  const sliceName = allocateTempName(ctx.state, "alloc_slice");
  const blockName = allocateTempName(ctx.state, "alloc_blk");
  const stdImport = `@import("std")`;
  const lenCast = `@as(usize, @intCast(${lenExpr}))`;
  return `${blockName}: { const ${sliceName} = ${stdImport}.heap.page_allocator.alloc(${typeExpr}, ${lenCast}) catch @panic("allocSlice failed"); break :${blockName} .{ .ptr = ${sliceName}.ptr, .len = ${sliceName}.len }; }`;
}

function emitLet(
  expr: CoreExpr & { kind: "let" },
  ctx: EmitContext,
): string {
  const scope = new Map(ctx.scope);
  const value = emitExpr(expr.binding.value, ctx);
  const label = allocateTempName(ctx.state, "blk");
  
  // For discarded statement results (__stmt_*), use _ to avoid unused variable warning
  if (expr.binding.name.startsWith("__stmt")) {
    const innerCtx = { ...ctx, scope };
    const body = emitExpr(expr.body, innerCtx);
    return `${label}: { _ = ${value}; break :${label} ${body}; }`;
  }
  
  // Bind the variable BEFORE emitting the body so it's in scope
  const ref = bindLocal(scope, expr.binding.name, ctx.state);
  const unusedGuard = isIntentionallyUnusedName(expr.binding.name)
    ? ` _ = ${ref.value};`
    : "";
  const innerCtx = { ...ctx, scope };
  const body = emitExpr(expr.body, innerCtx);
  return `${label}: { const ${ref.value} = ${value};${unusedGuard} break :${label} ${body}; }`;
}

function emitMatch(
  expr: CoreExpr & { kind: "match" },
  ctx: EmitContext,
): string {
  const scrutinee = emitExpr(expr.scrutinee, ctx);
  const clauses = expr.cases.map((c) => emitMatchCase(c, scrutinee, ctx));
  if (expr.fallback) {
    const fallbackBody = emitExpr(expr.fallback, ctx);
    clauses.push(`else => ${fallbackBody}`);
  }
  return `switch (${scrutinee}) { ${clauses.join(", ")} }`;
}

function emitMatchCase(
  matchCase: CoreMatchCase,
  scrutinee: string,
  ctx: EmitContext,
): string {
  const scope = new Map(ctx.scope);
  bindPatternVars(matchCase.pattern, scope, ctx.state);
  const innerCtx = { ...ctx, scope };
  const body = emitExpr(matchCase.body, innerCtx);
  if (isWildcardPattern(matchCase.pattern)) {
    return `else => ${body}`;
  }
  if (matchCase.pattern.kind === "constructor" && matchCase.pattern.fields.length > 0) {
    const args = matchCase.pattern.fields.map((a) => emitPattern(a, ctx)).join(", ");
    return `.${matchCase.pattern.constructor} => |${args}| ${body}`;
  }
  const pattern = emitPattern(matchCase.pattern, ctx);
  if (pattern === "_") {
    return `else => ${body}`;
  }
  return `${pattern} => ${body}`;
}

function isWildcardPattern(pattern: CorePattern): boolean {
  switch (pattern.kind) {
    case "wildcard":
    case "all_errors":
      return true;
    case "binding":
      return pattern.name === "_";
    default:
      return false;
  }
}

function emitPattern(pattern: CorePattern, ctx: EmitContext): string {
  switch (pattern.kind) {
    case "wildcard":
      return "_";
    case "binding":
      return sanitizeIdentifier(pattern.name, ctx.state);
    case "literal":
      return emitLiteral(pattern.literal, ctx);
    case "constructor":
      if (pattern.fields.length === 0) {
        return `.${pattern.constructor}`;
      }
      return `.${pattern.constructor}`;
    case "tuple":
      const elements = pattern.elements.map((e) => emitPattern(e, ctx)).join(", ");
      return `.{ ${elements} }`;
    case "pinned":
      return sanitizeIdentifier(pattern.name, ctx.state);
    case "all_errors":
      return "_";
  }
}

function bindPatternVars(
  pattern: CorePattern,
  scope: Map<string, VarRef>,
  state: NameState,
): void {
  switch (pattern.kind) {
    case "binding":
      bindLocal(scope, pattern.name, state);
      break;
    case "constructor":
      for (const field of pattern.fields) {
        bindPatternVars(field, scope, state);
      }
      break;
    case "tuple":
      for (const el of pattern.elements) {
        bindPatternVars(el, scope, state);
      }
      break;
    case "wildcard":
    case "literal":
    case "pinned":
    case "all_errors":
      break;
  }
}

function emitIf(
  expr: CoreExpr & { kind: "if" },
  ctx: EmitContext,
): string {
  const cond = emitExpr(expr.condition, ctx);
  const thenBranch = emitExpr(expr.thenBranch, ctx);
  const elseBranch = emitExpr(expr.elseBranch, ctx);
  return `if (${cond}) ${thenBranch} else ${elseBranch}`;
}

function emitPrimOp(op: CorePrimOp, args: readonly CoreExpr[], ctx: EmitContext): string {
  // Special case for record_get - extract field name from string literal
  if (op === "record_get") {
    const target = emitExpr(args[0], ctx);
    const fieldArg = args[1];
    // Field name is passed as a string literal
    if (fieldArg.kind === "literal" && fieldArg.literal.kind === "string") {
      const fieldName = fieldArg.literal.value;
      return `${target}.${fieldName}`;
    }
    // Fallback - shouldn't happen
    return `${target}.${emitExpr(fieldArg, ctx)}`;
  }
  
  const emittedArgs = [...args].map((a) => emitExpr(a, ctx));
  
  switch (op) {
    case "int_add":
      return `(${emittedArgs[0]} + ${emittedArgs[1]})`;
    case "int_sub":
      return `(${emittedArgs[0]} - ${emittedArgs[1]})`;
    case "int_mul":
      return `(${emittedArgs[0]} * ${emittedArgs[1]})`;
    case "int_div":
      return `@divTrunc(${emittedArgs[0]}, ${emittedArgs[1]})`;
    case "int_eq":
      return `(${emittedArgs[0]} == ${emittedArgs[1]})`;
    case "int_ne":
      return `(${emittedArgs[0]} != ${emittedArgs[1]})`;
    case "int_lt":
      return `(${emittedArgs[0]} < ${emittedArgs[1]})`;
    case "int_le":
      return `(${emittedArgs[0]} <= ${emittedArgs[1]})`;
    case "int_gt":
      return `(${emittedArgs[0]} > ${emittedArgs[1]})`;
    case "int_ge":
      return `(${emittedArgs[0]} >= ${emittedArgs[1]})`;
    case "int_cmp":
      return `std.math.order(${emittedArgs[0]}, ${emittedArgs[1]})`;
    case "bool_and":
      return `(${emittedArgs[0]} and ${emittedArgs[1]})`;
    case "bool_or":
      return `(${emittedArgs[0]} or ${emittedArgs[1]})`;
    case "bool_not":
      return `(!${emittedArgs[0]})`;
    case "char_eq":
      return `(${emittedArgs[0]} == ${emittedArgs[1]})`;
    case "string_length":
      return `${emittedArgs[0]}.len`;
    case "string_slice":
      return `${emittedArgs[0]}[${emittedArgs[1]}..${emittedArgs[2]}]`;
    case "native_print":
      return `std.debug.print("{any}", .{${emittedArgs[0]}})`;
    case "address_of":
      return `&${emittedArgs[0]}`;
  }
}

function emitData(
  expr: CoreExpr & { kind: "data" },
  ctx: EmitContext,
): string {
  if (expr.fields.length === 0) {
    return `.${expr.constructor}`;
  }
  const args = expr.fields.map((a) => emitExpr(a, ctx)).join(", ");
  return `.{ .${expr.constructor} = .{ ${args} } }`;
}

function emitTuple(
  expr: CoreExpr & { kind: "tuple" },
  ctx: EmitContext,
): string {
  const elements = expr.elements.map((e) => emitExpr(e, ctx)).join(", ");
  return `.{ ${elements} }`;
}

function resolveRecordTypeReference(type: Type | undefined, ctx: EmitContext): string | null {
  if (!type) return null;
  if (type.kind === "constructor") {
    const aliased = ctx.typeBindings.get(type.name);
    if (aliased) {
      return aliased;
    }
    const scoped = ctx.scope.get(type.name);
    if (scoped) {
      return scoped.value;
    }
    return sanitizeIdentifier(type.name, ctx.state);
  }
  return null;
}

function emitLetRec(
  expr: CoreExpr & { kind: "let_rec" },
  ctx: EmitContext,
): string {
  const scope = new Map(ctx.scope);
  const refs: string[] = [];
  const capturedVarsMap = new Map<string, string[]>();
  
  // First pass: bind all recursive function names so they can reference each other
  for (const binding of expr.bindings) {
    bindLocal(scope, binding.name, ctx.state);
  }
  
  // For let rec, we need to hoist lambda definitions to module level
  // but also handle captured variables by passing them as extra parameters
  for (const binding of expr.bindings) {
    const ref = scope.get(binding.name)!;
    refs.push(ref.value);
    
    if (binding.value.kind === "lambda") {
      // Find free variables that are captured from outer scope
      const lambdaParams = new Set(binding.value.params);
      const recNames = new Set(expr.bindings.map(b => b.name));
      const freeVars = collectFreeVars(binding.value.body, lambdaParams, recNames);
      
      // Filter out module-level names and built-in operators
      const capturedVars = freeVars.filter(v => 
        !ctx.moduleNames.has(v) && !RAW_OPERATOR_MAP.has(v)
      );
      capturedVarsMap.set(binding.name, capturedVars);
      
      // Also store in context so emitCall can find it
      ctx.capturedVarsMap.set(binding.name, capturedVars);
      
      // Hoist the function with extra parameters for captured vars
      const fnCode = emitNamedLambdaWithCaptures(binding.value, ref.value, capturedVars, { ...ctx, scope });
      ctx.hoisted.push(fnCode);
    } else {
      // Non-lambda bindings can't really be recursive, emit inline
      ctx.hoisted.push(`const ${ref.value} = ${emitExpr(binding.value, { ...ctx, scope })};`);
    }
  }
  
  const innerCtx = { ...ctx, scope, captureInfo: mergeCaptureInfo(ctx, capturedVarsMap) };
  
  return emitExpr(expr.body, innerCtx);
}

/** Collect free variables in an expression that aren't bound locally */
function collectFreeVars(expr: CoreExpr, bound: Set<string>, recNames: Set<string>): string[] {
  const free = new Set<string>();
  
  function walk(e: CoreExpr, localBound: Set<string>): void {
    switch (e.kind) {
      case "var":
        if (!localBound.has(e.name) && !recNames.has(e.name)) {
          free.add(e.name);
        }
        break;
      case "lambda": {
        const newBound = new Set(localBound);
        for (const p of e.params) newBound.add(p);
        walk(e.body, newBound);
        break;
      }
      case "let": {
        walk(e.binding.value, localBound);
        const newBound = new Set(localBound);
        newBound.add(e.binding.name);
        walk(e.body, newBound);
        break;
      }
      case "let_rec": {
        const newBound = new Set(localBound);
        for (const b of e.bindings) newBound.add(b.name);
        for (const b of e.bindings) walk(b.value, newBound);
        walk(e.body, newBound);
        break;
      }
      case "call":
        walk(e.callee, localBound);
        for (const arg of e.args) walk(arg, localBound);
        break;
      case "if":
        walk(e.condition, localBound);
        walk(e.thenBranch, localBound);
        walk(e.elseBranch, localBound);
        break;
      case "match":
        walk(e.scrutinee, localBound);
        for (const c of e.cases) {
          const caseBound = new Set(localBound);
          collectPatternBindings(c.pattern, caseBound);
          walk(c.body, caseBound);
        }
        break;
      case "record":
        for (const f of e.fields) walk(f.value, localBound);
        break;
      case "tuple":
        for (const el of e.elements) walk(el, localBound);
        break;
      case "tuple_get":
        walk(e.target, localBound);
        break;
      case "data":
        for (const f of e.fields) walk(f, localBound);
        break;
      case "prim":
        for (const arg of e.args) walk(arg, localBound);
        break;
      case "literal":
      case "enum_literal":
        break;
    }
  }
  
  walk(expr, bound);
  return Array.from(free);
}

function collectPatternBindings(pattern: CorePattern, bound: Set<string>): void {
  switch (pattern.kind) {
    case "binding":
      bound.add(pattern.name);
      break;
    case "constructor":
      for (const f of pattern.fields) collectPatternBindings(f, bound);
      break;
    case "tuple":
      for (const el of pattern.elements) collectPatternBindings(el, bound);
      break;
  }
}

function emitNamedLambdaWithCaptures(
  expr: CoreExpr & { kind: "lambda" },
  name: string,
  capturedVars: string[],
  ctx: EmitContext,
): string {
  const paramTypes = getParamTypes(expr.type, expr.params.length);
  
  // Create a fresh scope for the function parameters
  const scope = new Map<string, VarRef>();
  
  // Build params list: original params + captured vars
  // Bind each parameter FIRST so we get consistent names
  const params: string[] = [];
  for (let i = 0; i < expr.params.length; i++) {
    const ref = bindLocal(scope, expr.params[i], ctx.state);
    const ptype = paramTypes[i] ? emitType(paramTypes[i]) : "anytype";
    params.push(`${ref.value}: ${ptype}`);
  }
  
  // Add captured vars as anytype parameters
  for (const v of capturedVars) {
    const ref = bindLocal(scope, v, ctx.state);
    params.push(`${ref.value}: anytype`);
  }
  
  const innerCtx = { ...ctx, scope };
  
  // For recursive calls within the body, we need to pass captured vars
  const capturesMap = new Map<string, string[]>();
  capturesMap.set(name, capturedVars);
  const bodyCtx = { ...innerCtx, captureInfo: mergeCaptureInfo(ctx, capturesMap) };
  const body = emitExpr(expr.body, bodyCtx);
  const returnType = emitType(expr.type);
  
  return `fn ${name}(${params.join(", ")}) ${returnType} { return ${body}; }`;
}

function mergeCaptureInfo(
  ctx: EmitContext,
  localCaptures: Map<string, string[]>,
): Map<string, string[]> {
  if (!ctx.captureInfo) {
    return localCaptures;
  }
  const merged = new Map(ctx.captureInfo);
  for (const [name, captures] of localCaptures.entries()) {
    merged.set(name, captures);
  }
  return merged;
}

function emitType(type: Type): string {
  switch (type.kind) {
    case "int":
      return "i32"; // Default to i32 for now
    case "bool":
      return "bool";
    case "char":
      return "u8";
    case "string":
      return "[]const u8";
    case "unit":
      return "void";
    case "func":
      // For function types, we need the return type
      return emitType(getReturnType(type));
    case "constructor":
      // Optional<T> maps to Zig ?T
      if (type.name === "Optional" && type.args.length === 1) {
        return `?${emitType(type.args[0])}`;
      }
      // Null is a raw-only placeholder that maps to Zig's null-capable type.
      if (type.name === "Null" && type.args.length === 0) {
        return "?anyopaque";
      }
      // Handle Ptr<T> -> *T
      if (type.name === "Ptr" && type.args.length === 1) {
        return `*${emitType(type.args[0])}`;
      }
      // Opaque types like i32, u64 etc. - emit directly
      if (type.args.length === 0) {
        return type.name;
      }
      // Generic types like List<T> - emit as Type(args)
      const typeArgs = type.args.map(emitType).join(", ");
      return `${type.name}(${typeArgs})`;
    case "tuple":
      const elements = type.elements.map(emitType).join(", ");
      return `struct { ${elements} }`;
    case "record":
      const fields = Array.from(type.fields.entries())
        .map(([name, t]) => `${name}: ${emitType(t)}`)
        .join(", ");
      return `struct { ${fields} }`;
    case "var":
      return "anytype";
    default:
      return "anytype";
  }
}

function getReturnType(type: Type): Type {
  if (type.kind === "func") {
    return getReturnType(type.to);
  }
  return type;
}

function getParamTypes(type: Type, count: number): Type[] {
  const types: Type[] = [];
  let current = type;
  for (let i = 0; i < count && current.kind === "func"; i++) {
    types.push(current.from);
    current = current.to;
  }
  return types;
}
