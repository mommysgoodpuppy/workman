from "std/list/core" import { Empty, Link };
from "std/core/int" import { intAdd, intSub, intCompare };
from "std/result/core" import { IOk, IErr };
from "std/core/ordering" import { LT, EQ, GT };
from "std/option/core" import { Some, None };

export let rec listLength = match(list) {
  Empty => { 0 },
  Link(_, rest) => { intAdd(1, listLength(rest)) }
};

export let rec listAppend = match(xs, ys) {
  (Empty, ys) => { ys },
  (Link(x, rest), ys) => { Link(x, listAppend(rest, ys)) }
};

export let rec listMap = match(f, list) {
  (f, Empty) => { Empty },
  (f, Link(x, rest)) => { Link(f(x), listMap(f, rest)) }
};

export let rec listFilter = match(predicate, list) {
  (predicate, Empty) => { Empty },
  (predicate, Link(x, rest)) => {
    match(predicate(x)) {
      true => { Link(x, listFilter(predicate, rest)) },
      false => { listFilter(predicate, rest) }
    }
  }
};

export let rec listTake = match(list, count) {
  (Empty, _) => { Empty },
  (_, 0) => { Empty },
  (Link(x, rest), count) => { Link(x, listTake(rest, intSub(count, 1))) }
};

export let rec listDrop = match(list, count) {
  (list, 0) => { list },
  (Empty, _) => { Empty },
  (Link(_, rest), count) => { listDrop(rest, intSub(count, 1)) }
};

export let listSlice = (list, start, end) => {
  let dropped = listDrop(list, start);
  listTake(dropped, intSub(end, start))
};

export let rec listAt = match(list, index, error) {
  (Empty, _, error) => { IErr(error) },
  (Link(x, _), 0, _) => { IOk(x) },
  (Link(_, rest), index, error) => { listAt(rest, intSub(index, 1), error) }
};


export let rec listFoldl = match(f, acc, list) {
  (f, acc, Empty) => { acc },
  (f, acc, Link(x, rest)) => { listFoldl(f, f(acc, x), rest) }
};

export let rec listFoldr = match(f, acc, list) {
  (f, acc, Empty) => { acc },
  (f, acc, Link(x, rest)) => { f(x, listFoldr(f, acc, rest)) }
};

let rec reverseAcc = match(list, acc) {
  (Empty, acc) => { acc },
  (Link(x, rest), acc) => { reverseAcc(rest, Link(x, acc)) }
};

export let listReverse = (list) => {
  reverseAcc(list, Empty)
};

export let rec listRange = match(start, finish) {
  (start, finish) => {
    match(intCompare(start, finish)) {
      GT => { Empty },
      _ => { Link(start, listRange(intAdd(start, 1), finish)) }
    }
  }
};

export let rec listInsertBy = match(cmp, value, list) {
  (cmp, value, list) => {
    match(list) {
      Empty => { Link(value, Empty) },
      Link(x, rest) => {
        match(cmp(value, x)) {
          GT => { Link(x, listInsertBy(cmp, value, rest)) },
          _ => { Link(value, Link(x, rest)) }
        }
      }
    }
  }
};

export let rec listInsertionSortBy = match(cmp, list) {
  (cmp, list) => {
    match(list) {
      Empty => { Empty },
      Link(x, rest) => { listInsertBy(cmp, x, listInsertionSortBy(cmp, rest)) }
    }
  }
};

export let listSortInt = (list) => {
  listInsertionSortBy(intCompare, list)
};

-- Join a list of lists with a separator
-- For strings: listJoin(separator, listOfStrings)
export let rec listJoin = match(sep, list) {
  (sep, Empty) => { Empty },
  (sep, Link(x, Empty)) => { x },
  (sep, Link(x, rest)) => { listAppend(x, listAppend(sep, listJoin(sep, rest))) }
};

-- Execute a function for each element (for side effects)
export let rec listForEach = match(f, list) {
  (f, Empty) => { () },
  (f, Link(x, rest)) => {
    let result = f(x);
    listForEach(f, rest)
  }
};

-- Map and flatten: f returns a list for each element
export let rec listFlatMap = match(f, list) {
  (f, Empty) => { Empty },
  (f, Link(x, rest)) => { listAppend(f(x), listFlatMap(f, rest)) }
};

-- Find first element matching predicate
export let rec listFind = match(predicate, list) {
  (predicate, Empty) => { None },
  (predicate, Link(x, rest)) => {
    match(predicate(x)) {
      true => { Some(x) },
      false => { listFind(predicate, rest) }
    }
  }
};

-- Check if any element matches predicate
export let rec listAny = match(predicate, list) {
  (predicate, Empty) => { false },
  (predicate, Link(x, rest)) => {
    match(predicate(x)) {
      true => { true },
      false => { listAny(predicate, rest) }
    }
  }
};

-- Check if all elements match predicate
export let rec listAll = match(predicate, list) {
  (predicate, Empty) => { true },
  (predicate, Link(x, rest)) => {
    match(predicate(x)) {
      false => { false },
      true => { listAll(predicate, rest) }
    }
  }
};

-- Zip two lists into pairs
export let rec listZip = match(xs, ys) {
  (Empty, _) => { Empty },
  (_, Empty) => { Empty },
  (Link(x, restX), Link(y, restY)) => { Link((x, y), listZip(restX, restY)) }
};

-- Partition list into two based on predicate (true, false)
-- Returns a record with 'trues' and 'falses' fields
export let rec listPartition = match(predicate, list) {
  (predicate, Empty) => { ({ trues: Empty, falses: Empty }) },
  (predicate, Link(x, rest)) => {
    let partitioned = listPartition(predicate, rest);
    match(predicate(x)) {
      true => { ({ trues: Link(x, partitioned.trues), falses: partitioned.falses }) },
      false => { ({ trues: partitioned.trues, falses: Link(x, partitioned.falses) }) }
    }
  }
};
