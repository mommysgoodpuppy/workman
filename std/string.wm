-- String library for Workman
-- Strings are represented as List<Int> where each Int is a character code
-- ASCII character codes: 'A' = 65, 'a' = 97, '0' = 48, ' ' = 32, etc.
from "std/core/string" import { strFromLiteral };
from "std/coretypes" import { Some, None };
from "std/coretypes" import { Empty, Link };
from "std/core/int" import { intAdd as add, intSub as sub, intMul as mul, intDiv as div, intCompare as cmpInt, intEq as eq };
from "std/coretypes" import { IOk, IErr, LT, EQ, GT };

-- Type alias for clarity (just documentation, not enforced)
-- type String = List<Int>;
export type CharErr =
  | EmptyLiteral
  | MultiCharLiteral;

export let fromLiteral = (literal) => {
  strFromLiteral(literal)
};

export let char = (literal) => {
  match(strFromLiteral(literal)) {
    Empty => { IErr(EmptyLiteral) },
    Link(code, rest) => {
      match(rest) {
        Empty => { IOk(code) },
        _ => { IErr(MultiCharLiteral) }
      }
    }
  }
};

-- Character code constants
export let charSpace = () => {
  32
};
export let charTab = () => {
  9
};
export let charNewline = () => {
  10
};
export let charReturn = () => {
  13
};
export let char0 = () => {
  48
};
export let char9 = () => {
  57
};
export let charA = () => {
  65
};
export let charZ = () => {
  90
};
export let charLowerA = () => {
  97
};
export let charLowerZ = () => {
  122
};

-- Get the length of a string (just list length)
export let rec strLength = match(s) => {
  Empty => { 0 },
  Link(_, rest) => { add(1, strLength(rest)) }
};

-- Check if string is empty
export let strIsEmpty = (s) => {
  match(s) {
    Empty => { true },
    _ => { false }
  }
};

export let rec strCharAt = match(s, n) => {
  (Empty, _) => { None },
  (Link(c, _), 0) => { Some(c) },
  (Link(_, rest), idx) => { strCharAt(rest, sub(idx, 1)) }
};

-- Take first n characters
export let rec strTake = match(s, n) => {
  (_, 0) => { Empty },
  (Empty, _) => { Empty },
  (Link(c, rest), count) => { Link(c, strTake(rest, sub(count, 1))) }
};

-- Drop first n characters
export let rec strDrop = match(s, n) => {
  (value, 0) => { value },
  (Empty, _) => { Empty },
  (Link(_, rest), count) => { strDrop(rest, sub(count, 1)) }
};

-- Substring from start (inclusive) to end (exclusive)
export let strSlice = (s, start, end) => {
  let dropped = () => {
    strDrop(s, start)
  };
  let len = () => {
    sub(end, start)
  };
  strTake(dropped(), len())
};

-- Concatenate two strings
export let rec strConcat = match(s1, s2) => {
  (Empty, tail) => { tail },
  (Link(c, rest), tail) => { Link(c, strConcat(rest, tail)) }
};

-- Check if character is a digit (0-9)
export let isDigit = (c) => {
  let ge0 = () => {
    match(cmpInt(c, char0())) {
      LT => { false },
      _ => { true }
    }
  };
  let le9 = () => {
    match(cmpInt(c, char9())) {
      GT => { false },
      _ => { true }
    }
  };
  match(ge0()) {
    false => { false },
    true => { le9() }
  }
};

-- Check if character is uppercase letter (A-Z)
export let isUppercase = (c) => {
  let geA = () => {
    match(cmpInt(c, charA())) {
      LT => { false },
      _ => { true }
    }
  };
  let leZ = () => {
    match(cmpInt(c, charZ())) {
      GT => { false },
      _ => { true }
    }
  };
  match(geA()) {
    false => { false },
    true => { leZ() }
  }
};

-- Check if character is lowercase letter (a-z)
export let isLowercase = (c) => {
  let gea = () => {
    match(cmpInt(c, charLowerA())) {
      LT => { false },
      _ => { true }
    }
  };
  let lez = () => {
    match(cmpInt(c, charLowerZ())) {
      GT => { false },
      _ => { true }
    }
  };
  match(gea()) {
    false => { false },
    true => { lez() }
  }
};

-- Check if character is alphabetic (A-Z or a-z)
export let isAlpha = (c) => {
  match(isUppercase(c)) {
    true => { true },
    false => { isLowercase(c) }
  }
};

-- Check if character is alphanumeric
export let isAlphaNum = (c) => {
  match(isAlpha(c)) {
    true => { true },
    false => { isDigit(c) }
  }
};

-- Check if character is whitespace
export let isWhitespace = (c) => {
  match(eq(c, charSpace())) {
    true => { true },
    false => {
      match(eq(c, charTab())) {
        true => { true },
        false => {
          match(eq(c, charNewline())) {
            true => { true },
            false => { eq(c, charReturn()) }
          }
        }
      }
    }
  }
};

-- String equality
export let rec strEq = match(s1, s2) => {
  (Empty, Empty) => { true },
  (Empty, _) => { false },
  (_, Empty) => { false },
  (Link(c1, rest1), Link(c2, rest2)) => {
    match(eq(c1, c2)) {
      false => { false },
      true => { strEq(rest1, rest2) }
    }
  }
};

-- Convert single digit to character code
export let digitToChar = (n) => {
  add(char0(), n)
};

-- Convert character code to digit (returns Option<Int>)
export let charToDigit = (c) => {
  match(isDigit(c)) {
    false => { None },
    true => { Some(sub(c, char0())) }
  }
};

-- Helper: convert positive integer to string
let rec intToStringPositive = (n) => {
  match(eq(n, 0)) {
    true => { Empty },
    false => {
      let digit = digitToChar(sub(n, mul(div(n, 10), 10)));
      let rest = intToStringPositive(div(n, 10));
      strConcat(rest, Link(digit, Empty))
    }
  }
};

-- Convert integer to string (list of char codes)
export let intToString = (n) => {
  -- Handle zero specially
  match(eq(n, 0)) {
    true => { Link(char0(), Empty) },
    false => {
      -- Handle negative numbers
      match(cmpInt(n, 0)) {
        LT => {
          -- Negative: prepend '-' (45) to absolute value
          let absStr = intToStringPositive(sub(0, n));
          Link(45, absStr)
        },
        _ => { intToStringPositive(n) }
      }
    }
  }
};

-- Check if string starts with prefix
export let rec strStartsWith = match(str, pre) => {
  (_, Empty) => { true },
  (Empty, _) => { false },
  (Link(c1, rest1), Link(c2, rest2)) => {
    match(eq(c1, c2)) {
      false => { false },
      true => { strStartsWith(rest1, rest2) }
    }
  }
};

-- Check if string ends with suffix
export let strEndsWith = (str, suffix) => {
  let strLen = strLength(str);
  let suffixLen = strLength(suffix);
  match(cmpInt(suffixLen, strLen)) {
    GT => { false },
    _ => {
      let start = sub(strLen, suffixLen);
      strEq(strDrop(str, start), suffix)
    }
  }
};

-- Check if string contains substring
let rec strContainsAt = match(haystack, needle, pos) => {
  (haystack, needle, pos) => {
    match(strStartsWith(strDrop(haystack, pos), needle)) {
      true => { true },
      false => {
        let nextPos = add(pos, 1);
        match(cmpInt(nextPos, strLength(haystack))) {
          GT => { false },
          _ => { strContainsAt(haystack, needle, nextPos) }
        }
      }
    }
  }
};

export let strContains = (haystack, needle) => {
  match(strIsEmpty(needle)) {
    true => { true },
    false => { strContainsAt(haystack, needle, 0) }
  }
};

-- Split string by delimiter
let rec strSplitHelper = match(str, delim, acc, current) => {
  (Empty, delim, acc, current) => {
    -- End of string, add final part
    match(strIsEmpty(current)) {
      true => { acc },
      false => { Link(current, acc) }
    }
  },
  (Link(c, rest), delim, acc, current) => {
    match(strStartsWith(Link(c, rest), delim)) {
      true => {
        -- Found delimiter, save current part and skip delimiter
        let newAcc = Link(current, acc);
        let afterDelim = strDrop(Link(c, rest), strLength(delim));
        strSplitHelper(afterDelim, delim, newAcc, Empty)
      },
      false => {
        -- Not delimiter, add char to current part
        strSplitHelper(rest, delim, acc, Link(c, current))
      }
    }
  }
};

export let strSplit = (str, delim) => {
  let rec reverseList = match(list, acc) => {
    (Empty, acc) => { acc },
    (Link(x, rest), acc) => { reverseList(rest, Link(x, acc)) }
  };
  let rec reverseAll = match(list) => {
    Empty => { Empty },
    Link(x, rest) => { Link(reverseList(x, Empty), reverseAll(rest)) }
  };
  match(strIsEmpty(delim)) {
    true => { Link(str, Empty) },
    false => {
      let parts = strSplitHelper(str, delim, Empty, Empty);
      reverseAll(reverseList(parts, Empty))
    }
  }
};

-- Trim whitespace from start
export let rec strTrimStart = match(s) => {
  Empty => { Empty },
  Link(c, rest) => {
    match(isWhitespace(c)) {
      true => { strTrimStart(rest) },
      false => { Link(c, rest) }
    }
  }
};

-- Trim whitespace from end
export let strTrimEnd = (s) => {
  let rec reverseList = match(list, acc) => {
    (Empty, acc) => { acc },
    (Link(x, rest), acc) => { reverseList(rest, Link(x, acc)) }
  };
  let reversed = reverseList(s, Empty);
  let trimmed = strTrimStart(reversed);
  reverseList(trimmed, Empty)
};

-- Trim whitespace from both ends
export let strTrim = (s) => {
  strTrimEnd(strTrimStart(s))
};

-- Split string into lines
export let strLines = (s) => {
  strSplit(s, Link(charNewline(), Empty))
};

-- Join list of strings with separator
export let rec strJoin = match(sep, strings) => {
  (sep, Empty) => { Empty },
  (sep, Link(s, Empty)) => { s },
  (sep, Link(s, rest)) => { strConcat(s, strConcat(sep, strJoin(sep, rest))) }
};

-- Convert positive integer string to int
export let posIntStringToInt = (s) => {
  let rec helper = match(chars, acc) => {
    (Empty, acc) => { Some(acc) },
    (Link(c, rest), acc) => {
      match(charToDigit(c)) {
        None => { None },
        Some(digit) => { helper(rest, add(mul(acc, 10), digit)) }
      }
    }
  };
  match(strIsEmpty(s)) {
    true => { None },
    false => { helper(s, 0) }
  }
};

-- convert charactercode to a string
export let charCToString = (c: Int) => {
  Link(c, Empty)
};

-- Find index of character in string
-- Returns the 0-based index of the first occurrence, or None
export let rec strIndexOfChar = match(char, str, idx) => {
  (char, Empty, idx) => { None },
  (char, Link(c, rest), idx) => {
    match (eq(char, c)) {
      true => { Some(idx) },
      false => { strIndexOfChar(char, rest, add(idx, 1)) }
    }
  }
};

export let strIndexOf = (char, str) => {
  strIndexOfChar(char, str, 0)
};

-- Find index of substring in string
let rec strIndexOfStrAt = (needle, haystack, pos) => {
  match (strStartsWith(strDrop(haystack, pos), needle)) {
    true => { Some(pos) },
    false => {
      match (cmpInt(pos, strLength(haystack))) {
        GT => { None },
        EQ => { None },
        LT => { strIndexOfStrAt(needle, haystack, add(pos, 1)) }
      }
    }
  }
};

export let strIndexOfStr = (needle, haystack) => {
  match (strIsEmpty(needle)) {
    true => { Some(0) },
    false => { strIndexOfStrAt(needle, haystack, 0) }
  }
};

-- String is already List<Int>, so these are identity functions
-- stringToList : String -> List<Int>
export let stringToList = (s) => { s };

-- stringFromList : List<Int> -> String
export let stringFromList = (chars) => { chars };

-- Replicate a string n times
export let rec strReplicate = match(n, str) => {
  (0, _) => { Empty },
  (n, str) => { strConcat(str, strReplicate(sub(n, 1), str)) }
};

-- Pad string on left to reach target length
export let strPadLeft = (targetLen, padChar, str) => {
  let len = strLength(str);
  match (cmpInt(len, targetLen)) {
    LT => {
      let padding = strReplicate(sub(targetLen, len), Link(padChar, Empty));
      strConcat(padding, str)
    },
    _ => { str }
  }
};

-- Pad string on right to reach target length
export let strPadRight = (targetLen, padChar, str) => {
  let len = strLength(str);
  match (cmpInt(len, targetLen)) {
    LT => {
      let padding = strReplicate(sub(targetLen, len), Link(padChar, Empty));
      strConcat(str, padding)
    },
    _ => { str }
  }
};

-- Convert character to uppercase
export let charToUpper = (c) => {
  match (isLowercase(c)) {
    true => { sub(c, 32) },
    false => { c }
  }
};

-- Convert character to lowercase
export let charToLower = (c) => {
  match (isUppercase(c)) {
    true => { add(c, 32) },
    false => { c }
  }
};

-- Convert string to uppercase
export let rec strToUpper = match(s) => {
  Empty => { Empty },
  Link(c, rest) => { Link(charToUpper(c), strToUpper(rest)) }
};

-- Convert string to lowercase
export let rec strToLower = match(s) => {
  Empty => { Empty },
  Link(c, rest) => { Link(charToLower(c), strToLower(rest)) }
};
