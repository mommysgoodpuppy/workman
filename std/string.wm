-- String library for Workman
-- Strings are represented as List<Int> where each Int is a character code
-- ASCII character codes: 'A' = 65, 'a' = 97, '0' = 48, ' ' = 32, etc.

from "std/core/string" import { strFromLiteral };
from "std/option/core" import { Some, None };
from "std/list/core" import { Empty, Link };
from "std/core/int" import { intAdd as add, intSub as sub, intMul as mul, intDiv as div, intCompare as cmpInt, intEq as eq };
from "std/core/ordering" import { LT, EQ, GT };

-- Type alias for clarity (just documentation, not enforced)
-- type String = List<Int>;

export let fromLiteral = (literal) => {
  strFromLiteral(literal)
};

-- Character code constants
export let charSpace = () => {
  32
};
export let charTab = () => {
  9
};
export let charNewline = () => {
  10
};
export let charReturn = () => {
  13
};
export let char0 = () => {
  48
};
export let char9 = () => {
  57
};
export let charA = () => {
  65
};
export let charZ = () => {
  90
};
export let charLowerA = () => {
  97
};
export let charLowerZ = () => {
  122
};

-- Get the length of a string (just list length)
export let rec strLength = match(s) {
  Empty => { 0 },
  Link(_, rest) => { add(1, strLength(rest)) }
};

-- Check if string is empty
export let strIsEmpty = (s) => {
  match(s) {
    Empty => { true },
    _ => { false }
  }
};

-- Get character at index (returns Option<Int>)
export let rec strCharAt = match(tuple) {
  (Empty, _) => { None },
  (Link(c, _), 0) => { Some(c) },
  (Link(_, rest), n) => { strCharAt((rest, sub(n, 1))) }
};

-- Take first n characters
export let rec strTake = match(tuple) {
  (_, 0) => { Empty },
  (Empty, _) => { Empty },
  (Link(c, rest), n) => { Link(c, strTake((rest, sub(n, 1)))) }
};

-- Drop first n characters
export let rec strDrop = match(tuple) {
  (s, 0) => { s },
  (Empty, _) => { Empty },
  (Link(_, rest), n) => { strDrop((rest, sub(n, 1))) }
};

-- Substring from start (inclusive) to end (exclusive)
export let strSlice = (s, start, end) => {
  let dropped = () => {
    strDrop((s, start))
  };
  let len = () => {
    sub(end, start)
  };
  strTake((dropped(), len()))
};

-- Concatenate two strings
export let rec strConcat = match(tuple) {
  (Empty, s2) => { s2 },
  (Link(c, rest), s2) => { Link(c, strConcat((rest, s2))) }
};

-- Check if character is a digit (0-9)
export let isDigit = (c) => {
  let ge0 = () => {
    match(cmpInt(c, char0())) {
        LT => { false },
        _ => { true }
      }
  };
  let le9 = () => {
    match(cmpInt(c, char9())) {
        GT => { false },
        _ => { true }
      }
  };
  match(ge0()) {
    false => { false },
    true => { le9() }
  }
};

-- Check if character is uppercase letter (A-Z)
export let isUppercase = (c) => {
  let geA = () => {
    match(cmpInt(c, charA())) {
        LT => { false },
        _ => { true }
      }
  };
  let leZ = () => {
    match(cmpInt(c, charZ())) {
        GT => { false },
        _ => { true }
      }
  };
  match(geA()) {
    false => { false },
    true => { leZ() }
  }
};

-- Check if character is lowercase letter (a-z)
export let isLowercase = (c) => {
  let gea = () => {
    match(cmpInt(c, charLowerA())) {
        LT => { false },
        _ => { true }
      }
  };
  let lez = () => {
    match(cmpInt(c, charLowerZ())) {
        GT => { false },
        _ => { true }
      }
  };
  match(gea()) {
    false => { false },
    true => { lez() }
  }
};

-- Check if character is alphabetic (A-Z or a-z)
export let isAlpha = (c) => {
  match(isUppercase(c)) {
    true => { true },
    false => { isLowercase(c) }
  }
};

-- Check if character is alphanumeric
export let isAlphaNum = (c) => {
  match(isAlpha(c)) {
    true => { true },
    false => { isDigit(c) }
  }
};

-- Check if character is whitespace
export let isWhitespace = (c) => {
  match(eq(c, charSpace())) {
    true => { true },
    false => {
      match(eq(c, charTab())) {
        true => { true },
        false => {
          match(eq(c, charNewline())) {
            true => { true },
            false => { eq(c, charReturn()) }
          }
        }
      }
    }
  }
};

-- String equality
export let rec strEq = match(tuple) {
  (Empty, Empty) => { true },
  (Empty, _) => { false },
  (_, Empty) => { false },
  (Link(c1, rest1), Link(c2, rest2)) => {
    match(eq(c1, c2)) {
      false => { false },
      true => { strEq((rest1, rest2)) }
    }
  }
};

-- Convert single digit to character code
export let digitToChar = (n) => {
  add(char0(), n)
};

-- Convert character code to digit (returns Option<Int>)
export let charToDigit = (c) => {
  match(isDigit(c)) {
    false => { None },
    true => { Some(sub(c, char0())) }
  }
};

-- Helper: convert positive integer to string
let rec intToStringPositive = (n) => {
  match(eq(n, 0)) {
    true => { Empty },
    false => {
      let digit = digitToChar(sub(n, mul(div(n, 10), 10)));
      let rest = intToStringPositive(div(n, 10));
      strConcat((rest, Link(digit, Empty)))
    }
  }
};

-- Convert integer to string (list of char codes)
export let intToString = (n) => {
  -- Handle zero specially
  match(eq(n, 0)) {
    true => { Link(char0(), Empty) },
    false => {
      -- Handle negative numbers
      match(cmpInt(n, 0)) {
        LT => {
          -- Negative: prepend '-' (45) to absolute value
          let absStr = intToStringPositive(sub(0, n));
          Link(45, absStr)
        },
        _ => { intToStringPositive(n) }
      }
    }
  }
};


