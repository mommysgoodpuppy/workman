-- String library for Workman
-- Strings are represented as List<Int> where each Int is a character code
-- ASCII character codes: 'A' = 65, 'a' = 97, '0' = 48, ' ' = 32, etc.

from "std/core/string" import { strFromLiteral };
from "std/option/core" import { Some, None };
from "std/list/core" import { Empty, Link };
from "std/core/int" import { intAdd as add, intSub as sub, intMul as mul, intDiv as div, intCompare as cmpInt, intEq as eq };
from "std/core/ordering" import { LT, EQ, GT };
from "std/result/core" import { Ok, Err };

-- Type alias for clarity (just documentation, not enforced)
-- type String = List<Int>;

type CharLiteralErrorInternal =
  EmptyLiteral
  | MultiCharLiteral;

export type CharLiteralError = CharLiteralErrorInternal;

export let fromLiteral = (literal) => {
  strFromLiteral(literal)
};

export let char = (literal) => {
  match(strFromLiteral(literal)) {
    Empty => { Err(EmptyLiteral) },
    Link(code, rest) => {
      match(rest) {
        Empty => { Ok(code) },
        _ => { Err(MultiCharLiteral) }
      }
    }
  }
};

-- Character code constants
export let charSpace = () => {
  32
};
export let charTab = () => {
  9
};
export let charNewline = () => {
  10
};
export let charReturn = () => {
  13
};
export let char0 = () => {
  48
};
export let char9 = () => {
  57
};
export let charA = () => {
  65
};
export let charZ = () => {
  90
};
export let charLowerA = () => {
  97
};
export let charLowerZ = () => {
  122
};

-- Get the length of a string (just list length)
export let rec strLength = match(s) {
  Empty => { 0 },
  Link(_, rest) => { add(1, strLength(rest)) }
};

-- Check if string is empty
export let strIsEmpty = (s) => {
  match(s) {
    Empty => { true },
    _ => { false }
  }
};

export let rec strCharAt = match(s, n) {
  (Empty, _) => { None },
  (Link(c, _), 0) => { Some(c) },
  (Link(_, rest), idx) => { strCharAt(rest, sub(idx, 1)) }
};

-- Take first n characters
export let rec strTake = match(s, n) {
  (_, 0) => { Empty },
  (Empty, _) => { Empty },
  (Link(c, rest), count) => { Link(c, strTake(rest, sub(count, 1))) }
};

-- Drop first n characters
export let rec strDrop = match(s, n) {
  (value, 0) => { value },
  (Empty, _) => { Empty },
  (Link(_, rest), count) => { strDrop(rest, sub(count, 1)) }
};

-- Substring from start (inclusive) to end (exclusive)
export let strSlice = (s, start, end) => {
  let dropped = () => {
    strDrop(s, start)
  };
  let len = () => {
    sub(end, start)
  };
  strTake(dropped(), len())
};

-- Concatenate two strings
export let rec strConcat = match(s1, s2) {
  (Empty, tail) => { tail },
  (Link(c, rest), tail) => { Link(c, strConcat(rest, tail)) }
};

-- Check if character is a digit (0-9)
export let isDigit = (c) => {
  let ge0 = () => {
    match(cmpInt(c, char0())) {
        LT => { false },
        _ => { true }
      }
  };
  let le9 = () => {
    match(cmpInt(c, char9())) {
        GT => { false },
        _ => { true }
      }
  };
  match(ge0()) {
    false => { false },
    true => { le9() }
  }
};

-- Check if character is uppercase letter (A-Z)
export let isUppercase = (c) => {
  let geA = () => {
    match(cmpInt(c, charA())) {
        LT => { false },
        _ => { true }
      }
  };
  let leZ = () => {
    match(cmpInt(c, charZ())) {
        GT => { false },
        _ => { true }
      }
  };
  match(geA()) {
    false => { false },
    true => { leZ() }
  }
};

-- Check if character is lowercase letter (a-z)
export let isLowercase = (c) => {
  let gea = () => {
    match(cmpInt(c, charLowerA())) {
        LT => { false },
        _ => { true }
      }
  };
  let lez = () => {
    match(cmpInt(c, charLowerZ())) {
        GT => { false },
        _ => { true }
      }
  };
  match(gea()) {
    false => { false },
    true => { lez() }
  }
};

-- Check if character is alphabetic (A-Z or a-z)
export let isAlpha = (c) => {
  match(isUppercase(c)) {
    true => { true },
    false => { isLowercase(c) }
  }
};

-- Check if character is alphanumeric
export let isAlphaNum = (c) => {
  match(isAlpha(c)) {
    true => { true },
    false => { isDigit(c) }
  }
};

-- Check if character is whitespace
export let isWhitespace = (c) => {
  match(eq(c, charSpace())) {
    true => { true },
    false => {
      match(eq(c, charTab())) {
        true => { true },
        false => {
          match(eq(c, charNewline())) {
            true => { true },
            false => { eq(c, charReturn()) }
          }
        }
      }
    }
  }
};

-- String equality
export let rec strEq = match(s1, s2) {
  (Empty, Empty) => { true },
  (Empty, _) => { false },
  (_, Empty) => { false },
  (Link(c1, rest1), Link(c2, rest2)) => {
    match(eq(c1, c2)) {
      false => { false },
      true => { strEq(rest1, rest2) }
    }
  }
};

-- Convert single digit to character code
export let digitToChar = (n) => {
  add(char0(), n)
};

-- Convert character code to digit (returns Option<Int>)
export let charToDigit = (c, error) => {
  match(isDigit(c)) {
    false => { Err(error) },
    true => { Ok(sub(c, char0())) }
  }
};

-- Helper: convert positive integer to string
let rec intToStringPositive = (n) => {
  match(eq(n, 0)) {
    true => { Empty },
    false => {
      let digit = digitToChar(sub(n, mul(div(n, 10), 10)));
      let rest = intToStringPositive(div(n, 10));
      strConcat(rest, Link(digit, Empty))
    }
  }
};

-- Convert integer to string (list of char codes)
export let intToString = (n) => {
  -- Handle zero specially
  match(eq(n, 0)) {
    true => { Link(char0(), Empty) },
    false => {
      -- Handle negative numbers
      match(cmpInt(n, 0)) {
        LT => {
          -- Negative: prepend '-' (45) to absolute value
          let absStr = intToStringPositive(sub(0, n));
          Link(45, absStr)
        },
        _ => { intToStringPositive(n) }
      }
    }
  }
};

-- Check if string starts with prefix
export let rec strStartsWith = match(str, pre) {
  (_, Empty) => { true },
  (Empty, _) => { false },
  (Link(c1, rest1), Link(c2, rest2)) => {
    match(eq(c1, c2)) {
      false => { false },
      true => { strStartsWith(rest1, rest2) }
    }
  }
};

-- Check if string ends with suffix
export let strEndsWith = (str, suffix) => {
  let strLen = strLength(str);
  let suffixLen = strLength(suffix);
  match(cmpInt(suffixLen, strLen)) {
    GT => { false },
    _ => {
      let start = sub(strLen, suffixLen);
      strEq(strDrop(str, start), suffix)
    }
  }
};

-- Check if string contains substring
let rec strContainsAt = match(haystack, needle, pos) {
  (haystack, needle, pos) => {
    match(strStartsWith(strDrop(haystack, pos), needle)) {
      true => { true },
      false => {
        let nextPos = add(pos, 1);
        match(cmpInt(nextPos, strLength(haystack))) {
          GT => { false },
          _ => { strContainsAt(haystack, needle, nextPos) }
        }
      }
    }
  }
};

export let strContains = (haystack, needle) => {
  match(strIsEmpty(needle)) {
    true => { true },
    false => { strContainsAt(haystack, needle, 0) }
  }
};

-- Split string by delimiter
let rec strSplitHelper = match(str, delim, acc, current) {
  (Empty, delim, acc, current) => {
    -- End of string, add final part
    match(strIsEmpty(current)) {
      true => { acc },
      false => { Link(current, acc) }
    }
  },
  (Link(c, rest), delim, acc, current) => {
    match(strStartsWith(Link(c, rest), delim)) {
      true => {
        -- Found delimiter, save current part and skip delimiter
        let newAcc = Link(current, acc);
        let afterDelim = strDrop(Link(c, rest), strLength(delim));
        strSplitHelper(afterDelim, delim, newAcc, Empty)
      },
      false => {
        -- Not delimiter, add char to current part
        strSplitHelper(rest, delim, acc, Link(c, current))
      }
    }
  }
};

export let strSplit = (str, delim) => {
  let rec reverseList = match(list, acc) {
    (Empty, acc) => { acc },
    (Link(x, rest), acc) => { reverseList(rest, Link(x, acc)) }
  };
  let rec reverseAll = match(list) {
    Empty => { Empty },
    Link(x, rest) => { Link(reverseList(x, Empty), reverseAll(rest)) }
  };
  match(strIsEmpty(delim)) {
    true => { Link(str, Empty) },
    false => {
      let parts = strSplitHelper(str, delim, Empty, Empty);
      reverseAll(reverseList(parts, Empty))
    }
  }
};

-- Trim whitespace from start
export let rec strTrimStart = match(s) {
  Empty => { Empty },
  Link(c, rest) => {
    match(isWhitespace(c)) {
      true => { strTrimStart(rest) },
      false => { Link(c, rest) }
    }
  }
};

-- Trim whitespace from end
export let strTrimEnd = (s) => {
  let rec reverseList = match(list, acc) {
    (Empty, acc) => { acc },
    (Link(x, rest), acc) => { reverseList(rest, Link(x, acc)) }
  };
  let reversed = reverseList(s, Empty);
  let trimmed = strTrimStart(reversed);
  reverseList(trimmed, Empty)
};

-- Trim whitespace from both ends
export let strTrim = (s) => {
  strTrimEnd(strTrimStart(s))
};

-- Split string into lines
export let strLines = (s) => {
  strSplit(s, Link(charNewline(), Empty))
};

-- Join list of strings with separator
export let rec strJoin = match(sep, strings) {
  (sep, Empty) => { Empty },
  (sep, Link(s, Empty)) => { s },
  (sep, Link(s, rest)) => { strConcat(s, strConcat(sep, strJoin(sep, rest))) }
};
