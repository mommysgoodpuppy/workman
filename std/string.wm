-- String library for Workman
-- Strings are represented as List<Int> where each Int is a character code
-- ASCII character codes: 'A' = 65, 'a' = 97, '0' = 48, ' ' = 32, etc.

from "std/core/string" import { strFromLiteral };
from "std/option/core" import { Some, None };
from "std/list/core" import { Empty, Link };
from "std/core/int" import { intAdd as add, intSub as sub, intMul as mul, intDiv as div, intCompare as cmpInt, intEq as eq };
from "std/core/ordering" import { LT, EQ, GT };
from "std/result/core" import { Ok, Err };

-- Type alias for clarity (just documentation, not enforced)
-- type String = List<Int>;

type CharLiteralErrorInternal =
  EmptyLiteral
  | MultiCharLiteral;

export type CharLiteralError = CharLiteralErrorInternal;

export let fromLiteral = (literal) => {
  strFromLiteral(literal)
};

export let char = (literal) => {
  match(strFromLiteral(literal)) {
    Empty => { Err(EmptyLiteral) },
    Link(code, rest) => {
      match(rest) {
        Empty => { Ok(code) },
        _ => { Err(MultiCharLiteral) }
      }
    }
  }
};

-- Character code constants
export let charSpace = () => {
  32
};
export let charTab = () => {
  9
};
export let charNewline = () => {
  10
};
export let charReturn = () => {
  13
};
export let char0 = () => {
  48
};
export let char9 = () => {
  57
};
export let charA = () => {
  65
};
export let charZ = () => {
  90
};
export let charLowerA = () => {
  97
};
export let charLowerZ = () => {
  122
};

-- Get the length of a string (just list length)
export let rec strLength = match(s) {
  Empty => { 0 },
  Link(_, rest) => { add(1, strLength(rest)) }
};

-- Check if string is empty
export let strIsEmpty = (s) => {
  match(s) {
    Empty => { true },
    _ => { false }
  }
};

export let rec strCharAt = match(s, n) {
  (Empty, _) => { None },
  (Link(c, _), 0) => { Some(c) },
  (Link(_, rest), idx) => { strCharAt(rest, sub(idx, 1)) }
};

-- Take first n characters
export let rec strTake = match(s, n) {
  (_, 0) => { Empty },
  (Empty, _) => { Empty },
  (Link(c, rest), count) => { Link(c, strTake(rest, sub(count, 1))) }
};

-- Drop first n characters
export let rec strDrop = match(s, n) {
  (value, 0) => { value },
  (Empty, _) => { Empty },
  (Link(_, rest), count) => { strDrop(rest, sub(count, 1)) }
};

-- Substring from start (inclusive) to end (exclusive)
export let strSlice = (s, start, end) => {
  let dropped = () => {
    strDrop(s, start)
  };
  let len = () => {
    sub(end, start)
  };
  strTake(dropped(), len())
};

-- Concatenate two strings
export let rec strConcat = match(s1, s2) {
  (Empty, tail) => { tail },
  (Link(c, rest), tail) => { Link(c, strConcat(rest, tail)) }
};

-- Check if character is a digit (0-9)
export let isDigit = (c) => {
  let ge0 = () => {
    match(cmpInt(c, char0())) {
        LT => { false },
        _ => { true }
      }
  };
  let le9 = () => {
    match(cmpInt(c, char9())) {
        GT => { false },
        _ => { true }
      }
  };
  match(ge0()) {
    false => { false },
    true => { le9() }
  }
};

-- Check if character is uppercase letter (A-Z)
export let isUppercase = (c) => {
  let geA = () => {
    match(cmpInt(c, charA())) {
        LT => { false },
        _ => { true }
      }
  };
  let leZ = () => {
    match(cmpInt(c, charZ())) {
        GT => { false },
        _ => { true }
      }
  };
  match(geA()) {
    false => { false },
    true => { leZ() }
  }
};

-- Check if character is lowercase letter (a-z)
export let isLowercase = (c) => {
  let gea = () => {
    match(cmpInt(c, charLowerA())) {
        LT => { false },
        _ => { true }
      }
  };
  let lez = () => {
    match(cmpInt(c, charLowerZ())) {
        GT => { false },
        _ => { true }
      }
  };
  match(gea()) {
    false => { false },
    true => { lez() }
  }
};

-- Check if character is alphabetic (A-Z or a-z)
export let isAlpha = (c) => {
  match(isUppercase(c)) {
    true => { true },
    false => { isLowercase(c) }
  }
};

-- Check if character is alphanumeric
export let isAlphaNum = (c) => {
  match(isAlpha(c)) {
    true => { true },
    false => { isDigit(c) }
  }
};

-- Check if character is whitespace
export let isWhitespace = (c) => {
  match(eq(c, charSpace())) {
    true => { true },
    false => {
      match(eq(c, charTab())) {
        true => { true },
        false => {
          match(eq(c, charNewline())) {
            true => { true },
            false => { eq(c, charReturn()) }
          }
        }
      }
    }
  }
};

-- String equality
export let rec strEq = match(s1, s2) {
  (Empty, Empty) => { true },
  (Empty, _) => { false },
  (_, Empty) => { false },
  (Link(c1, rest1), Link(c2, rest2)) => {
    match(eq(c1, c2)) {
      false => { false },
      true => { strEq(rest1, rest2) }
    }
  }
};

-- Convert single digit to character code
export let digitToChar = (n) => {
  add(char0(), n)
};

-- Convert character code to digit (returns Option<Int>)
export let charToDigit = (c, error) => {
  match(isDigit(c)) {
    false => { Err(error) },
    true => { Ok(sub(c, char0())) }
  }
};

-- Helper: convert positive integer to string
let rec intToStringPositive = (n) => {
  match(eq(n, 0)) {
    true => { Empty },
    false => {
      let digit = digitToChar(sub(n, mul(div(n, 10), 10)));
      let rest = intToStringPositive(div(n, 10));
      strConcat(rest, Link(digit, Empty))
    }
  }
};

-- Convert integer to string (list of char codes)
export let intToString = (n) => {
  -- Handle zero specially
  match(eq(n, 0)) {
    true => { Link(char0(), Empty) },
    false => {
      -- Handle negative numbers
      match(cmpInt(n, 0)) {
        LT => {
          -- Negative: prepend '-' (45) to absolute value
          let absStr = intToStringPositive(sub(0, n));
          Link(45, absStr)
        },
        _ => { intToStringPositive(n) }
      }
    }
  }
};
