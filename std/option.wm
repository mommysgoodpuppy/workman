from "std/coretypes" import { Some, None };
from "std/coretypes" import { Empty, Link };
export from "std/coretypes" type Option(..);

export let map = match(f, option) => {
  (f, Some(value)) => { Some(f(value)) },
  (_, None) => { None }
};

export let flatMap = match(f, option) =>{
  (f, Some(value)) => { f(value) },
  (_, None) => { None }
};

export let withDefault = match(defaultValue, option) => {
  (defaultValue, Some(value)) => { value },
  (defaultValue, None) => { defaultValue }
};

export let orElse = match(fallback, option) => {
  (fallback, Some(value)) => { Some(value) },
  (fallback, None) => { fallback() }
};

-- Pipeable alternative: option :> alt(fallback)
-- Like orElse but with option first for use with :> pipe operator
-- Name from Haskell's Alternative typeclass (<|>)
export let alt = match(option, fallback) => {
  (Some(value), fallback) => { Some(value) },
  (None, fallback) => { fallback() }
};

export let fromBool = match(condition, value) => {
  (true, value) => { Some(value) },
  (false, _) => { None }
};

export let toList = match(option) => {
  Some(value) => { Link(value, Empty) },
  None => { Empty }
};
-- Check if option contains a value
export let isSome = match(option) => {
  Some(_) => { true },
  None => { false }
};

-- Check if option is empty
export let isNone = match(option) => {
  Some(_) => { false },
  None => { true }
};

-- Apply a function if Some, otherwise return None
export let filter = match(pred, option) => {
  (pred, Some(value)) => {
    match (pred(value)) {
      true => { Some(value) },
      false => { None }
    }
  },
  (_, None) => { None }
};

-- Combine two options (both must be Some)
export let map2 = match(f, opt1, opt2) => {
  (f, Some(a), Some(b)) => { Some(f(a, b)) },
  (_, _, _) => { None }
};

-- Sequence a list of options: all must be Some, or result is None
export let rec optionSequence = match(options) => {
  Empty => { Some(Empty) },
  Link(opt, rest) => {
    match (opt) {
      None => { None },
      Some(value) => {
        match (optionSequence(rest)) {
          None => { None },
          Some(values) => { Some(Link(value, values)) }
        }
      }
    }
  }
};

-- Traverse: map a function that returns Option, then sequence
export let rec optionTraverse = match(f, list) => {
  (f, Empty) => { Some(Empty) },
  (f, Link(x, rest)) => {
    match (f(x)) {
      None => { None },
      Some(y) => {
        match (optionTraverse(f, rest)) {
          None => { None },
          Some(ys) => { Some(Link(y, ys)) }
        }
      }
    }
  }
};

-- Flatten nested Option
export let flatten = match(opt) => {
  Some(inner) => { inner },
  None => { None }
};

-- Get value or panic (unsafe - use sparingly)
-- Note: This will just return () if None since we don't have panic yet
export let unwrap = match(option) => {
  Some(value) => { value },
  None => { Panic("unwrap called on None") }
};

-- Zip two options together
export let zip = match(opt1, opt2) => {
  (Some(a), Some(b)) => { Some((a, b)) },
  (_, _) => { None }
};