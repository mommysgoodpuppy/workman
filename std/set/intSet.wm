-- IntSet: Set of integers using association list
-- O(n) operations, but simple and correct. Upgrade to balanced tree later.
-- Useful for visited sets, free variables, etc.
from "std/coretypes" import { Empty, Link };
from "std/coretypes" import { Some, None };

-- IntSet is a list of unique integers
export type IntSet = IntSetEmpty | IntSetCons<Int, IntSet>;

-- Empty set
export let intSetEmpty = IntSetEmpty;

-- Check if integer exists in set
export let rec intSetContains = match(key, set) => {
  (key, IntSetEmpty) => { false },
  (key, IntSetCons(k, rest)) => {
    match (key == k) {
      true => { true },
      false => { intSetContains(key, rest) }
    }
  }
};

-- Insert an integer (no duplicates)
export let intSetInsert = (key, set) => {
  match (intSetContains(key, set)) {
    true => { set },
    false => { IntSetCons(key, set) }
  }
};

-- Remove an integer
export let rec intSetRemove = match(key, set) => {
  (key, IntSetEmpty) => { IntSetEmpty },
  (key, IntSetCons(k, rest)) => {
    match (key == k) {
      true => { rest },
      false => { IntSetCons(k, intSetRemove(key, rest)) }
    }
  }
};

-- Convert to list
export let rec intSetToList = match(set) => {
  IntSetEmpty => { Empty },
  IntSetCons(k, rest) => { Link(k, intSetToList(rest)) }
};

-- Create from list
export let rec intSetFromList = match(list) => {
  Empty => { IntSetEmpty },
  Link(k, rest) => { intSetInsert(k, intSetFromList(rest)) }
};

-- Union of two sets
export let rec intSetUnion = match(s1, s2) => {
  (s1, IntSetEmpty) => { s1 },
  (s1, IntSetCons(k, rest)) => { 
    intSetUnion(intSetInsert(k, s1), rest) 
  }
};

-- Difference: s1 - s2 (elements in s1 but not in s2)
export let rec intSetDifference = match(s1, s2) => {
  (IntSetEmpty, _) => { IntSetEmpty },
  (IntSetCons(k, rest), s2) => {
    match (intSetContains(k, s2)) {
      true => { intSetDifference(rest, s2) },
      false => { IntSetCons(k, intSetDifference(rest, s2)) }
    }
  }
};

-- Intersection: elements in both sets
export let rec intSetIntersection = match(s1, s2) => {
  (IntSetEmpty, _) => { IntSetEmpty },
  (IntSetCons(k, rest), s2) => {
    match (intSetContains(k, s2)) {
      true => { IntSetCons(k, intSetIntersection(rest, s2)) },
      false => { intSetIntersection(rest, s2) }
    }
  }
};

-- Size of set
export let rec intSetSize = match(set) => {
  IntSetEmpty => { 0 },
  IntSetCons(_, rest) => { 1 + intSetSize(rest) }
};

-- Check if set is empty
export let intSetIsEmpty = match(set) => {
  IntSetEmpty => { true },
  _ => { false }
};

-- Fold over set
export let rec intSetFold = match(f, acc, set) => {
  (f, acc, IntSetEmpty) => { acc },
  (f, acc, IntSetCons(k, rest)) => { 
    intSetFold(f, f(acc, k), rest) 
  }
};

-- Map over set (applying f to each element)
export let rec intSetMap = match(f, set) => {
  (f, IntSetEmpty) => { IntSetEmpty },
  (f, IntSetCons(k, rest)) => { 
    intSetInsert(f(k), intSetMap(f, rest)) 
  }
};

-- Filter set
export let rec intSetFilter = match(pred, set) => {
  (pred, IntSetEmpty) => { IntSetEmpty },
  (pred, IntSetCons(k, rest)) => {
    match (pred(k)) {
      true => { IntSetCons(k, intSetFilter(pred, rest)) },
      false => { intSetFilter(pred, rest) }
    }
  }
};

-- Get minimum element (returns Option)
export let rec intSetMin = match(set) => {
  IntSetEmpty => { None },
  IntSetCons(k, rest) => {
    match (intSetMin(rest)) {
      None => { Some(k) },
      Some(m) => { 
        match (k < m) {
          true => { Some(k) },
          false => { Some(m) }
        }
      }
    }
  }
};

-- Get maximum element (returns Option)
export let rec intSetMax = match(set) => {
  IntSetEmpty => { None },
  IntSetCons(k, rest) => {
    match (intSetMax(rest)) {
      None => { Some(k) },
      Some(m) => { 
        match (k > m) {
          true => { Some(k) },
          false => { Some(m) }
        }
      }
    }
  }
};
