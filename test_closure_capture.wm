from "std/zig/mem" import { alloc, free, write };
from "std/nativeString" import { stringToList, stringConcat, intToString };

--this should error
let main = () => {
  let buffer = alloc(100);
  print(buffer);
  let useBuffer = () => {
    -- since closure capture is used closed infection also gets captured
    -- detecting the potential illegal operation
    'X' >> buffer[0];
  };
  free(buffer);
  useBuffer();
};

let main4 = () => {
  let buffer = alloc(100);
  -- technically illegal buffer is both
  -- open and closed in the same scope
  -- rected valid program but keeps workmans non-linear simplicity
  'X' >> buffer[0];
  free(buffer);
};

let main5 = () => {
  let useBuffer = () => {
    let buffer = alloc(100);
    'X' >> buffer[0];
    buffer
  };
  let buffer = useBuffer();
  -- double free
  -- buffer is which errors
  -- <Opened#r3053@1 | Closed#r3053@1 | Closed#r3053@2>
  free(buffer);
  free(buffer);
};


--this should be fine
let main2 = () => {
  let buffer = alloc(100);
  print(buffer);
  let useBuffer = (buffer) => {
    'X' >> buffer[0];
    buffer
  };
  -- we use a shadow so "closed" infection doesnt spread backwards
  let buffer2 = useBuffer(buffer);
  free(buffer2);
};


let main6 = () => {
  let buffer = alloc(100);
  print(buffer);
  let useBuffer = (buffer) => {
    'X' >> buffer[0];
    buffer
  };
  let buffer2 = useBuffer(buffer);
  'X' >> buffer[1]; -- no error here
  -- the free op here creates a new non linear context
  free(buffer2);
  -- free the alias then use the original, error detected
  'X' >> buffer[1];
};

--this should also be fine
let main3 = () => {

  let useBuffer = () => {
    let buffer = alloc(100);
    'X' >> buffer[0];
    buffer
  };
  -- also no backwards propagation
  free(useBuffer());
};