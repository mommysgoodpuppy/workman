from "std/string" import { fromLiteral, strEq };
from "std/list" import { listSlice, listAt, listLength};
from "std/string" import { charToDigit, char };

type ParseError =
  | NotMul
  | ExpectedDigit
  | ExpectedComma
  | ExpectedCloseParen;

record ParseStep { value: Int, next: Int };

-- helpers --------------------------------------------------------------
let charComma = char(",");
let charCloseParen = char(")");
let mulLiteral = fromLiteral("mul(");
let mulLiteralLength = listLength(mulLiteral);

let makeStep = (value, next) => {
  ({ value: value, next: next })
};

let readRequiredDigit = (chars, i) => {
  match(listAt(chars, i)) {
    None => { Err(ExpectedDigit) },
    Some(code) => {
      match(charToDigit(code)) {
        None => { Err(ExpectedDigit) },
        Some(digit) => { Ok(makeStep(digit, i + 1)) }
      }
    }
  }
};

let rec extendDigits = (chars, step, count) => {
  match(count == 3) {
    true => { Ok(step) },
    false => {
      match(listAt(chars, step.next)) {
        None => { Ok(step) },
        Some(code) => {
          match(charToDigit(code)) {
            None => { Ok(step) },
            Some(digit) => {
              let combined = makeStep(
                step.value * 10 + digit,
                step.next + 1
              );
              extendDigits(chars, combined, count + 1)
            }
          }
        }
      }
    }
  }
};

let readNumber = (chars, i) => {
  extendDigits(chars, readRequiredDigit(chars, i), 1)
};

let expectCharAt = (chars, i, expected, error) => {
  match(listAt(chars, i)) {
    None => { Err(error) },
    Some(code) => {
      match(code == expected) {
        true => { Ok(i + 1) },
        false => { Err(error) }
      }
    }
  }
};

let expectMulLiteral = (chars, i) => {
  match(strEq(listSlice(chars, i, i + mulLiteralLength), mulLiteral)) {
    true => { Ok(i + mulLiteralLength) },
    false => { Err(NotMul) }
  }
};

let parseLeft = (chars, i) => {
  readNumber(chars, i)
};

let parseComma = (chars, step) => {
  expectCharAt(chars, step.next, charComma, ExpectedComma)
};

let parseRight = (chars, i) => {
  readNumber(chars, i) 
};

let parseCloseParen = (chars, step) => {
  expectCharAt(chars, step.next, charCloseParen, ExpectedCloseParen)
};

let buildMulStep = (leftStep, rightStep, nextIndex) => {
  Ok(makeStep(leftStep.value * rightStep.value, nextIndex))
};

let parseMulAt = (chars, i) => {
  let afterMul = expectMulLiteral(chars, i);
  let leftStep = parseLeft(chars, afterMul);
  let afterComma = parseComma(chars, leftStep);
  let rightStep = parseRight(chars, afterComma);
  match(parseCloseParen(chars, rightStep)) {
    Ok(afterClose) => { buildMulStep(leftStep, rightStep, afterClose) },
    Err(error) => { Err(error) }
  }
};

-- scanner as a bundle --------------------------------------------------

let rec scan = (chars, i, acc) => {
  match(listAt(chars, i)) {
    None => { acc },
    Some(_) => {
      match(parseMulAt(chars, i)) {
        Ok(step) => { scan(chars, step.next, acc + step.value) },
        _ => { scan(chars, i + 1, acc) }
      }
    }
  }
};

-- top-level ------------------------------------------------------------

let corruptedMemory = fromLiteral("xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))");

let main = () => {
  print(scan(corruptedMemory, 0, 0))
};