from "std/string" import { fromLiteral, strEq };
from "std/list" import { listSlice, listAt, listLength};
from "std/string" import { charToDigit, char };

type ParseResult =
  | NotMul
  | ExpectedDigit
  | ExpectedComma
  | ExpectedCloseParen;

record ParseStep { value: Int, next: Int };

-- Build a cursor/value pair for downstream helpers.
let makeStep = (v, n) => {
  ({ value: v, next: n })
};

let charComma = char(",");
let charCloseParen = char(")");
let mulLiteral = fromLiteral("mul(");
let mulLiteralLength = listLength(mulLiteral);

-- Read exactly one digit or raise ExpectedDigit to the caller.
let readRequiredDigit = (chars, i) => {
  makeStep(
    charToDigit(listAt(chars, i, ExpectedDigit), ExpectedDigit),
    i + 1
  )
};

-- Extend up to three total digits, stopping cleanly if parsing fails.
let rec extendDigits = (chars, step, count) => {
  match(count == 3) {
    true => { step },
    false => {
      match(listAt(chars, step.next, ExpectedDigit)) {
        Err(_) => { step },
        Ok(code) => {
          match(charToDigit(code, ExpectedDigit)) {
            Err(_) => { step },
            Ok(digit) => {
              let combined = makeStep(
                step.value * 10 + digit,
                step.next + 1
              );
              extendDigits(chars, combined, count + 1)
            }
          }
        }
      }
    }
  }
};

-- Require a specific delimiter at the cursor.
let expectCharAt = (chars, i, expected, error) => {
  match(listAt(chars, i, error)) {
    Ok(code) => {
      match(code == expected) {
        true => { Ok(i + 1) },
        false => { Err(error) }
      }
    },
    _ => { Err(error) }
  }
};

-- Check for the mul( literal at a position, otherwise resume scanning.
let expectMulLiteral = (chars, i) => {
  match(strEq(listSlice(chars, i, i + mulLiteralLength), mulLiteral)) {
    true => { Ok(i + mulLiteralLength) },
    false => { Err(NotMul) }
  }
};

-- Parse mul(X,Y) at an index and return the product plus next cursor.
let parseMulAt = (chars, i) => {
  let afterMul = expectMulLiteral(chars, i);
  let leftStep = extendDigits(chars, readRequiredDigit(chars, afterMul), 1);
  let afterComma = expectCharAt(chars, leftStep.next, charComma, ExpectedComma);
  let rightStep = extendDigits(chars, readRequiredDigit(chars, afterComma), 1);
  makeStep(
    leftStep.value * rightStep.value,
    expectCharAt(chars, rightStep.next, charCloseParen, ExpectedCloseParen)
  )
};

-- scanner as a bundle --------------------------------------------------

-- Walk the memory, summing successful multiplications.
let rec scan = (chars, i, acc) => {
  match(listAt(chars, i, NotMul)) {
    Err(_) => { acc },
    Ok(_) => {
      match(parseMulAt(chars, i)) {
        Ok(step) => { scan(chars, step.next, acc + step.value) },
        _ => { scan(chars, i + 1, acc) }
      }
    }
  }
};

-- top-level ------------------------------------------------------------

let corruptedMemory = fromLiteral("xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))");

let main = () => {
  print(scan(corruptedMemory, 0, 0))
};
