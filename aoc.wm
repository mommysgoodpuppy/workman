from "std/nativeString" import { stringToList, stringConcat, intToString };
from "std/string" import { strEq };
from "std/list" import { listSlice, listAt, listLength };
from "std/string" import { charToDigit, char };

type ParseResult =
  | NotMul
  | ExpectedDigit
  | ExpectedComma
  | ExpectedCloseParen;

record ParseStep { value: Int, next: Int };

-- Build a cursor/value pair for downstream helpers.
let makeStep = (v, n) => {
  ({ value: v, next: n })
};

let charComma = char(",");
let charCloseParen = char(")");
let mulLiteral = stringToList("mul("); -- String literal â†’ List<Int>
let mulLiteralLength = listLength(mulLiteral);

-- Read exactly one digit or raise ExpectedDigit to the caller.
let readRequiredDigit = (chars, i) => {
  makeStep(
    charToDigit(listAt(chars, i, ExpectedDigit), ExpectedDigit),
    i + 1
  )
};

-- Extend up to three total digits, stopping cleanly if parsing fails.
let rec extendDigits = (chars, step, count) => {
  match(count == 3) {
    true => { step },
    false => {
      match(listAt(chars, step.next, ExpectedDigit)) {
        IErr(_) => { step },
        IOk(code) => {
          match(charToDigit(code, ExpectedDigit)) {
            IErr(_) => { step },
            IOk(digit) => {
              let combined = makeStep(
                step.value * 10 + digit,
                step.next + 1
              );
              extendDigits(chars, combined, count + 1)
            }
          }
        }
      }
    }
  }
};

-- Require a specific delimiter at the cursor.
let expectCharAt = (chars, i, expected, error) => {
  match(listAt(chars, i, error)) {
    IOk(code) => {
      match(code == expected) {
        true => { IOk(i + 1) },
        false => { IErr(error) }
      }
    },
    _ => { IErr(error) }
  }
};

-- Check for the mul( literal at a position, otherwise resume scanning.
let expectMulLiteral = (chars, i) => {
  match(strEq(listSlice(chars, i, i + mulLiteralLength), mulLiteral)) {
    true => { IOk(i + mulLiteralLength) },
    false => { IErr(NotMul) }
  }
};

-- Parse mul(X,Y) at an index and return the product plus next cursor.
let parseMulAt = (chars, i) => {
  let afterMul = expectMulLiteral(chars, i);
  let leftStep = extendDigits(chars, readRequiredDigit(chars, afterMul), 1);
  let afterComma = expectCharAt(chars, leftStep.next, charComma, ExpectedComma);
  let rightStep = extendDigits(chars, readRequiredDigit(chars, afterComma), 1);
  makeStep(
    leftStep.value * rightStep.value,
    expectCharAt(chars, rightStep.next, charCloseParen, ExpectedCloseParen)
  )
};

-- Walk the memory, summing successful multiplications.
let rec scan = (chars, i, acc) => {
  match(listAt(chars, i, NotMul)) {
    IErr(_) => { acc },
    IOk(_) => {
      match(parseMulAt(chars, i)) {
        IOk(step) => { scan(chars, step.next, acc + step.value) },
        IErr(NotMul) => {
          print("yay");
          print(stringConcat("skipping at ", intToString(i)));
          scan(chars, i + 1, acc)
        },
        IErr(ExpectedComma) => {
          print("ex comma");
          print(stringConcat("skipping at ", intToString(i)));
          scan(chars, i + 1, acc)
        },
        IErr(_) => {
          print(stringConcat("skipping at ", intToString(i)));
          scan(chars, i + 1, acc)
        }
      }
    }
  }
};

let corruptedMemory = stringToList("xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))");

let main = () => {
  print(scan(corruptedMemory, 0, 0))
};
