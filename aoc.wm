from "std/string" import { fromLiteral, strEq };
from "std/list" import { listSlice, listAt, listLength};
from "std/string" import { charToDigit, char };

type ParseResult =
  | NotMul
  | ExpectedDigit
  | ExpectedComma
  | ExpectedCloseParen;

record ParseStep { value: Int, next: Int };

let makeStep = (v, n) => {
  ({ value: v, next: n })
};

let charComma = char(",");
let charCloseParen = char(")");
let mulLiteral = fromLiteral("mul(");
let mulLiteralLength = listLength(mulLiteral);

let readRequiredDigit = (chars, i) => {
  match(listAt(chars, i, ExpectedDigit)) {
    Err(error) => { Err(error) },
    Ok(code) => {
      match(charToDigit(code, ExpectedDigit)) {
        Err(error) => { Err(error) },
        Ok(digit) => { Ok(makeStep(digit, i + 1)) }
      }
    }
  }
};

let rec extendDigits = (chars, step, count) => {
  match(count == 3) {
    true => { step },
    false => {
      match(listAt(chars, step.next, ExpectedDigit)) {
        Err(_) => { step },
        Ok(code) => {
          match(charToDigit(code, ExpectedDigit)) {
            Err(_) => { step },
            Ok(digit) => {
              let combined = makeStep(
                step.value * 10 + digit,
                step.next + 1
              );
              extendDigits(chars, combined, count + 1)
            }
          }
        }
      }
    }
  }
};

let expectCharAt = (chars, i, expected, error) => {
  match(listAt(chars, i, error)) {
    Ok(code) => {
      match(code == expected) {
        true => { Ok(i + 1) },
        false => { Err(error) }
      }
    },
    _ => { Err(error) }
  }
};

let expectMulLiteral = (chars, i) => {
  match(strEq(listSlice(chars, i, i + mulLiteralLength), mulLiteral)) {
    true => { Ok(i + mulLiteralLength) },
    false => { Err(NotMul) }
  }
};

let parseMulAt = (chars, i) => {
  let afterMul = expectMulLiteral(chars, i);
  let leftStep = extendDigits(chars, readRequiredDigit(chars, afterMul), 1);
  let afterComma = expectCharAt(chars, leftStep.next, charComma, ExpectedComma);
  let rightStep = extendDigits(chars, readRequiredDigit(chars, afterComma), 1);
  match(expectCharAt(chars, rightStep.next, charCloseParen, ExpectedCloseParen)) {
    Ok(afterClose) => { Ok(makeStep(leftStep.value * rightStep.value, afterClose)) },
    Err(error) => { Err(error) }
  }
};

-- scanner as a bundle --------------------------------------------------

let rec scan = (chars, i, acc) => {
  match(listAt(chars, i, NotMul)) {
    Err(_) => { acc },
    Ok(_) => {
      match(parseMulAt(chars, i)) {
        Ok(step) => { scan(chars, step.next, acc + step.value) },
        _ => { scan(chars, i + 1, acc) }
      }
    }
  }
};

-- top-level ------------------------------------------------------------

let corruptedMemory = fromLiteral("xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))");

let main = () => {
  print(scan(corruptedMemory, 0, 0))
};
